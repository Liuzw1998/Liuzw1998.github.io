<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuzw1998.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Zhenwei&#39;s Blog">
<meta property="og:url" content="https://liuzw1998.github.io/page/2/index.html">
<meta property="og:site_name" content="Zhenwei&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhenwei Liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liuzw1998.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

<script type="text/x-mathjax-config">
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
      tags: 'ams'
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  };
</script>

  <title>Zhenwei's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zhenwei's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/08/13/Approximation-Algorithm-5-The-MultiwayCut-Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/13/Approximation-Algorithm-5-The-MultiwayCut-Problem/" class="post-title-link" itemprop="url">Approximation Algorithm(5)-The MultiwayCut Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-13 11:39:39" itemprop="dateCreated datePublished" datetime="2019-08-13T11:39:39+00:00">2019-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Week 5: The MultiwayCut Problem</strong></p>
<h4 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h4><p>给出一个边权非负的无向图$G &#x3D; (V, E)$, 其中有$k$个顶点是terminals(之后记为$a_1 \cdots a_k, A :&#x3D; {a_i}$)。删掉边集$E’ \subset E$, 使得这$k$个顶点互相不连通，要求$weight(E’)$尽可能小。</p>
<h4 id="Trivial-Case-k-2"><a href="#Trivial-Case-k-2" class="headerlink" title="Trivial Case: $k&#x3D; 2$"></a>Trivial Case: $k&#x3D; 2$</h4><p>经典问题，最大流&#x3D;最小割，分别以两个terminals为源点和汇点做最大流。</p>
<h4 id="Small-Case-k-3"><a href="#Small-Case-k-3" class="headerlink" title="Small Case: $k&#x3D;3$"></a>Small Case: $k&#x3D;3$</h4><p>假设3个terminals分别是$a, b, c$, 考虑怎么把$k&#x3D;2$的做法利用起来。 </p>
<p>$mincut(S_1, S_2)$表示把$V$分成两个不相交集合$V_1,V_2$,并且$S_1 \subset V_1, S_2 \subset V_2$的最小割。</p>
<p>如何计算$mincut(S_1, S_2)$? 稍微熟悉网络流模型的就可以想到只要新建一个超级源向所有$S_1$中的点连容量无穷的边, 一个超级汇连容量无穷的边到所有$S_2$中的点跑网络流。</p>
<p>考虑$mincut({a}, {b,c}), mincut({b}, {a,c}), mincut({c}, {a,b})$这三种割。容易证明随便选2个并起来一定可以把$a,b,c$分开来，那么肯定选代价小的2个。</p>
<p>分析一下近似度：</p>
<p>最优解肯定不会小于上面3个cut的任意一个，因此</p>
<p>$$<br>OPT \geq \frac{1}{3}(mincut({a}, {b,c}) + mincut({b}, {a,c})+ mincut({c}, {a,b}))<br>$$</p>
<p>而我们选的是较小的2个，因此<br>$$<br>value(output) \leq \frac{2}{3}(mincut({a}, {b,c}) + mincut({b}, {a,c})+ mincut({c}, {a,b}))<br>$$<br>容易得到$value(output) \leq 2OPT$.</p>
<h4 id="General-Cases"><a href="#General-Cases" class="headerlink" title="General Cases"></a>General Cases</h4><p>记$mincut_i :&#x3D; mincut(a_i, A \backslash a_i)$, 从$k&#x3D;3$的情况容易扩展成选$mincut_1 \cdots mincut_k$中较小的$k-1$个作为答案。</p>
<p>用类似上面的方法分析很容易得到一个$value(output) \leq (k-1)OPT$的bound，不过进一步法分析还可以得到更紧的bound。</p>
<p>首先因为取的是最小的$k-1$个，肯定比随便取$k-1$个要好。随便取$k-1$个有$k$种方案，这$k$种方案的价值之和是$(k-1)\sum_i{mincut_i}$, 所以<br>$$<br>value(output) \leq \frac{k-1}{k}\sum_i{mincut_i}<br>$$<br>最优解OPT把原图分成了若干个联通块，设$a_i$所在的联通块是$A_i$, $F_i$表示只有一个端点在$A_i$中的边，因此<br>$$<br>\sum_i{w(F_i)} &#x3D; 2OPT<br>$$<br>因为$F_i$也是某种$Cut(a_i, A \backslash a_i)$,  所以<br>$$<br>mincut_i \leq w(F_i)<br>$$<br>结合几个不等式可以得到<br>$$<br>value(output) \leq 2(1-\frac{1}{k})OPT<br>$$<br>特别地, $k&#x3D;2$时$value(output) &#x3D; OPT$, $k&#x3D;3$时$value(output)\leq \frac{4}{3}OPT$.</p>
<h4 id="Algorithm-via-LP-and-Randomized-Rounding"><a href="#Algorithm-via-LP-and-Randomized-Rounding" class="headerlink" title="Algorithm via LP and Randomized Rounding"></a>Algorithm via LP and Randomized Rounding</h4><h5 id="Linear-Programming"><a href="#Linear-Programming" class="headerlink" title="Linear Programming"></a>Linear Programming</h5><ul>
<li>Variables:  $x_{u,i}$表示点$u$是否属于$a_i$所在的集合。</li>
<li>Contraints: $x_{u,i} \in [0,1], \sum_i{x_{u,i}&#x3D;1}$   </li>
<li>Objective: $\frac{1}{2} \sum\limits_{(u,v)\in E}w(u,v)(\sum\limits_i{|x_{u, i} - x_{v, i}|})$</li>
</ul>
<p>比较巧妙的地方是用$\sum\limits_i{|x_{u, i} - x_{v, i}|}$将$u,v$属于不同集合的条件表达出来了。<br>注意上面不是标准的LP, 可以令$d_{uvi} \geq x_{u, i} - x_{v, i}, d_{uvi} \geq x_{v, i} - x_{u, i}$, 然后将$|x_{u, i} - x_{v, i}|用d_{uvi}$替代, 转化为标准的LP。</p>
<h5 id="Geometric-Interpretation"><a href="#Geometric-Interpretation" class="headerlink" title="Geometric Interpretation"></a>Geometric Interpretation</h5><p>将每个点的信息看成一个$k$维向量: $\vec{X_u} :&#x3D; (x_{u,1}, x_{u,2} \cdots x_{u, k})$</p>
<p>$\sum\limits_i{|x_{u, i} - x_{v, i}|}&#x3D;|X_u - X_v|_1$, 即$X_u, X_v$的$L_1$距离。</p>
<p>令$d(u,v) :&#x3D; \frac{1}{2}|X_u-X_v|$, 那么总的cost就是$ \sum\limits_{(u,v)\in E}w(u,v)(\frac{1}{2}\sum\limits_i{|x_{u, i} - x_{v, i}|}) &#x3D; \sum\limits_{(u,v)\in E}w(u,v)d(u,v)$</p>
<p>LP的结果相当于返回了$|V|$个在$L_1$距离意义下的单位单纯形内部的点。</p>
<p>Rounding相当于将单纯形内部的点挪到顶点上。</p>
<p>LP的Objective相当于：如果某两个点$u,v$被挪到了不同顶点上，就要付出$w(u,v)$的代价。</p>
<h5 id="Randomized-Rounding"><a href="#Randomized-Rounding" class="headerlink" title="Randomized Rounding"></a>Randomized Rounding</h5><p>有点好奇算法的发明者是怎么想到的。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>随机一个实数$r \in [0,1]$(因为单纯形内任意两点$u,v$满足$d(u,v)\leq1$).</li>
<li>随机一个排列$\sigma_1, \cdots \sigma_k$.</li>
<li>对于每个待rounding的内部点$u$，依次考虑$a_{\sigma_1}, a_{\sigma_2} \cdots a_{\sigma_{k-1}}$，把这个点挪到第一个与它距离不超过$r$的顶点$a_{\sigma_i}$上(这里的距离指的是$d$, $d(u, a_{\sigma_i}) \leq r$)。 如果距离都大于$r$，把这个点挪到顶点$a_{\sigma_k}$上。</li>
</ol>
<p><strong>分析</strong>：</p>
<p>$u,v$被round到不同的顶点上当且仅当$a_{\sigma_1}, a_{\sigma_2} \cdots a_{\sigma_{k-1}}$中存在某个点$a$能将$u,v$分开, 即<br>$$<br>\min(d(a, u), d(a,v)) \leq r \lt max(d(a, u), d(a, v))<br>$$<br>设事件$Event_i$表示$a_i$恰好是第一个能将$u, v$分开的点, 那么有<br>$$<br>Pr[u,v \text{ are seperated}] &#x3D; \sum_i{Pr[Event_i]}<br>$$<br>设$l :&#x3D; \mathop {argmin}\limits_i{min(d(a_i, u), d(a_i, v))}$.</p>
<p>如果$i \neq l$, 那么$a_i$必须排在$a_l$的前面，这个概率是$\frac{1}{2}$, 同时需要满足<br>$$<br>\min(d(a_i, u), d(a_i,v)) \leq r \lt max(d(a_i, u), d(a_i, v))<br>$$<br>这个概率是$|d(a_i, u) - d(a_i, v)|$. 两个部分是独立事件，而$Event_i$要发生，至少需要满足这两个条件，因此<br>$$<br>Pr[Event_i] \leq \frac{1}{2}|d(a_i, u) - d(a_i, v)|<br>$$<br>如果$i &#x3D; l$, 那么首先$a_i$不能排在最后($a_{\sigma_k} \neq a_i$), 这个概率是$\frac{k-1}{k}$, 因此<br>$$<br>Pr[Event_i] \leq \frac{k-1}{k}|d(a_i, u) - d(a_i, v)|<br>$$</p>
<p>结合这两种情况，可以推出<br>$$<br>\begin{aligned}<br>&amp;Pr[u,v \text{ are seperated}] &#x3D; \sum_i{Pr[Event_i]}\<br>&amp;\leq \frac{k-1}{k}|d(a_i, u) - d(a_i, v)| + \sum_{i \neq l}\frac{1}{2}|d(a_i, u) - d(a_i, v)| \<br>&amp;&#x3D; (\frac{1}{2} -\frac{1}{k})|d(a_l, u) - d(a_l, v)| + \sum_i\frac{1}{2}|d(a_i, u) - d(a_i, v)| \<br>&amp;&#x3D; (\frac{1}{2} -\frac{1}{k})|\sum_j\frac{1}{2}|a_{l,j}-x_{u,j}| - \sum_j\frac{1}{2}|a_{l,j}-x_{v,j}|| + \sum_i\frac{1}{2}|\sum_j\frac{1}{2}|a_{i,j}-x_{u,j}| - \sum_j\frac{1}{2}|a_{i,j}-x_{v,j}|| \<br>&amp;&#x3D;  \frac{1}{2}(\frac{1}{2} -\frac{1}{k})|(1-x_{u,l})-(1-x_{v,l})+\sum_{j \neq l}{(x_{u,j}-x_{v,j})}|<br>+\frac{1}{4}\sum_i|(1-x_{u,i})-(1-x_{v,i})+\sum_{j \neq i}(x_{u,j}-x_{v,j})| \<br>&amp;&#x3D; \frac{1}{2}(\frac{1}{2} -\frac{1}{k})|\sum_j(x_{u,j}-x_{v,j})-2(x_{u,l}-x_{v,l})| -\frac{1}{4}\sum_i|\sum_{j}(x_{u,j}-x_{v,j})-2(x_{u,i}-x_{v,i})| \<br>&amp;&#x3D; (\frac{1}{2} -\frac{1}{k})|x_{u,l}-x_{v,l}|+\frac{1}{2}\sum_i|x_{u,i}-x_{v,i}|<br>\end{aligned}<br>$$</p>
<p>接下来用到一个不太显然的结论$|x_{u,l} - x_{v,l}| \leq \frac{1}{2}\sum_i|x_{u,i}-x_{v,i}|$</p>
<p>证明：</p>
<p>构造新的向量$X_1 :&#x3D; (x_{u,1}, \cdots ,x_{u,l-1}, x_{u,l+1}, \cdots x_{u,k}), X_2:&#x3D; (x_{u,1}, \cdots ,x_{v,l-1}, x_{v,l+1}, \cdots x_{v,k})$</p>
<p>$|X_1| &#x3D; 1-x_{u,l}, |X_2| &#x3D; 1-x_{v,l}, \sum_i|x_{u,i}-x_{v,i}|&#x3D;|X_1-X_2|+|x_{u,i}-x_{v,i}|$</p>
<p>根据$L_1$范数的三角形不等式$|X_1-X_2| \geq ||X_1|-|X_2|| &#x3D; |x_{u,l}-x_{v,l}|$</p>
<p>整合一下容易推出$|x_{u,l} - x_{v,l}| \leq \frac{1}{2}\sum_i|x_{u,i}-x_{v,i}|$。</p>
<p>利用这个小结论可以将$Pr[u,v \text{ are seperated}]$ 的式子中$|x_{u,l} - x_{v,l}| $的部分去掉：<br>$$<br>\begin{aligned}<br>Pr[u,v \text{ are seperated}] &amp;\leq (\frac{1}{2} -\frac{1}{k})|x_{u,l}-x_{v,l}|+\frac{1}{2}\sum_i|x_{u,i}-x_{v,i}| \<br>&amp;\leq (\frac{3}{2}-\frac{1}{k})(\frac{1}{2}\sum_i|x_{u,i}-x_{v,i}|)<br>\end{aligned}<br>$$<br>因此<br>$$<br>\begin{aligned}<br>E(output) &amp;&#x3D; \sum_{(u,v) \in E}w(u,v)Pr[u,v \text{ are seperated}] \<br>&amp;\leq (\frac{3}{2}-\frac{1}{k})\sum_{(u,v) \in E}(\frac{1}{2}\sum_i|x_{u,i}-x_{v,i}|)w(u,v)  \<br>&amp;\leq (\frac{3}{2}-\frac{1}{k}) OPT<br>\end{aligned}<br>$$</p>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><p>coursera上的作业题, 懒得把我的英文答案再翻译回中文了。。。<br>Consider the following algorithm.</p>
<img src="/2019/08/13/Approximation-Algorithm-5-The-MultiwayCut-Problem/2.jpg" class="">
<p>We define $P_0,\cdots, P_{k-1}$  to be the partitions of the vertices defined by the set $\mathcal{P}$ at the different stage of the algorithm. $P_0 &#x3D; V$ and for any $i&gt;0, P_i$ is the partition of the vertices defined by $\mathcal{P}$ at the $i^{th}$ iteration of the while loop.</p>
<p>We denote by $w(P_i)$ the sum of the weights of the edges that connect vertices lying in different parts of the partition induced by $P_i$. </p>
<p>Moreover, for any partition $\Gamma$ of the vertices of $G$, we say that the partition is valid if each part of the partition contains at least one terminal.</p>
<p>For any part $\Gamma_j \in \Gamma$, we define $w(\Gamma_j)$ as the sum of the weights of the edges having exactly one endpoint in $\Gamma_j$.</p>
<p>We aim at showing the following Lemma:</p>
<p><strong>Lemma</strong>: For any $i \leq k$, for any valid partition $\Gamma&#x3D;{\Gamma_1, \cdots, \Gamma_i}$ with $i$ parts<br>$$<br>w(P_{i−1}) \leq \sum_{j&#x3D;1}^{i−1}{w(\Gamma_j)}<br>$$</p>
<p><strong>Question 1</strong>: Argue that the case $i&#x3D;1$ holds.<br>We need to prove $w(P_0) \leq 0$.   Since $P_0 &#x3D; {V}$, there’s only one part of the partition, thus $w(P_0) &#x3D; 0.$</p>
<p>We now want to show that the statement is true for any $i$. We assume that it holds up to $i-1$. We consider an arbitrary valid partition$\Gamma&#x3D;{\Gamma_1, \cdots, \Gamma_i }$ with $i$ parts.</p>
<p><strong>Question 2</strong>: Consider the partition $P_{i-2}$. How many parts does it contain?<br>$i-1$ parts.</p>
<p><strong>Question 3</strong>. Argue that there exist two terminals which belong to the same part $B$ of $P_{i-2}$ but to two different parts $\Gamma_h, \Gamma_l$ of $\Gamma$.<br>Since $\Gamma$ is valid, each of the $\Gamma_i$ contains at least one terminal and let’s call them $v_1, v_2 \cdots v_{i}$. However there are only $i-1$ parts in $P_{i-2}$, so there must be  some $v_h \in \Gamma_h$ and $v_l \in \Gamma_l  $ with $h \neq l$ that belongs to the same part $B$ in $P_{i-2}$. </p>
<p><strong>Question 4</strong>: Compare the cost of splitting $B$ into $B\cap \Gamma_h$ and $B \backslash \Gamma_h$ to the difference $w(P_{i-1}) - w(P_{i-2})$.<br>$C_0(B):&#x3D;\text{minimum cost of splitting B into two parts with each containing  terminals }$<br>$C_1(B) :&#x3D; \text {cost of splitting B into } B \cap \Gamma_h \text{ and } B \backslash \Gamma_h$<br>Since the algorithm chooses to split the element with minimum cost, we have $w(P_{i-1} ) - w(P_{i-2}) \leq C_0(B) \leq C_1(B)$.</p>
<p><strong>Question 5</strong>: Conclude the proof of the Lemma using Question 4 and the induction hypothesis.<br>For convenience, let’s add one more constraint to $h, l$ in question 3: $h \lt l$ so that $h \leq i-1$ holds.<br>Consider another valid partition $\Gamma’ &#x3D; {\Gamma_1, \cdots \Gamma_{h-1}, \Gamma_{h+1}, \cdots \Gamma_{i-1},  \Gamma_h \cup \Gamma_i}$ with $|\Gamma’| &#x3D; i-1$. Assume the lemma holds for $i-1$ so we have  $w(P_{i-2})\leq \sum\limits_{1\leq j \leq i-1, j \neq h}w(\Gamma_j)$.  </p>
<p>   By question 4 we have:<br>$$<br>   \begin{aligned}<br>   w(P_{i-1}) -w(P_{i-2}) &amp;\leq C_1(B) \<br>   &amp;&#x3D; \sum\limits_{u \in B\cap\Gamma_h}\sum\limits_{v\in B \backslash \Gamma_h}w(u,v) \<br>   &amp;\leq \sum\limits_{u \in B\cap\Gamma_h}\sum\limits_{v\in V \backslash \Gamma_h}w(u,v) \<br>   &amp;\leq \sum\limits_{u \in \Gamma_h}\sum\limits_{v\in V \backslash \Gamma_h}w(u,v) \<br>   &amp;&#x3D; w(\Gamma_h)<br>   \end{aligned}<br>$$<br>   add the two inequations we can get  $w(P_{i-1}) \leq \sum\limits_{j&#x3D;1}^{i-1}{w(\Gamma_j)}$.</p>
<p><strong>Question 6</strong>. What is the approximation ratio? Conclude using the lectures and the lemma.<br>By the lemma we have $value(output) &#x3D; w(P_{k-1}) \leq \sum_{j&#x3D;1}^{k-1}{w(F_j)}$.<br>As $w(F_k)$ is the largest among $w(F_i)$, we have $w(F_k) \geq \frac{\sum_{j&#x3D;1}^{k-1}{w(F_j)}}{k-1}$.   Thus $2OPT &#x3D; \sum_{j&#x3D;1}^{k}{w(F_j) \geq (1+\frac{1}{k-1})\sum_{j&#x3D;1}^{k-1}{w(F_j)} }$<br>Combine them and we get $value(output) \leq \sum_{j&#x3D;1}^{k-1}{w(F_j)} \leq \frac{2}{1+\frac{1}{k-1}}OPT$ and the approximation ratio is $\frac{2}{1+\frac{1}{k-1}} &#x3D; 2(1-\frac{1}{k})$.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/08/09/Project-Euler-Problem-550-Divisor-Game/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/09/Project-Euler-Problem-550-Divisor-Game/" class="post-title-link" itemprop="url">Project Euler Problem 550-Divisor Game</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-09 18:53:02" itemprop="dateCreated datePublished" datetime="2019-08-09T18:53:02+00:00">2019-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>有$N$个大于等于2的正整数，两个人博弈，轮到某个人的回合，他需要选择其中一个数$X$，将它移走，然后加入两个新的正整数$X1, X2$, 满足$2\leq X1, X2 \lt N $ 并且$X1, X2$都是$X$的约数。 不能操作的人判定为失败。假定两个人都按照最优策略，问有多少种局面$a_1, a_2 \cdots a_{10^{12}}$, 满足$2 \leq a_i \leq 10^7$并且先手必胜。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>显然这是一个组合游戏，可以利用SG函数来判断谁必胜。</p>
<p>根据SG定理整个游戏的SG值等于各个子游戏的SG异或起来，因此只要知道如何计算$SG(n)$, 即只有一个数$n$的子游戏的SG值。</p>
<p>$$<br>SG(n) &#x3D; \mathop{mex}\limits_{d_1,d_2 | n}{ SG(d_1) \text{ xor } SG(d_2)}<br>$$</p>
<p>我们需要知道$SG(1 \cdots 10^{7})$, 直接计算复杂度太高。</p>
<p>思考游戏的本质，$SG(n &#x3D; p_1^{k_1}p_2^{k_2} \cdots p_l^{k_l})$ 实际上和$p_i$的取值无关，只和指数$k_i$有关。因此$SG(p_1^{k_1}p_2^{k_2} \cdots p_l^{k_l}) &#x3D; SG(2^{k_1}3^{k_2} \cdots prime_l^{k_l})$,即可以把$p_i$用第$i$个质数$prime_i$替代。另外${k_i}$的顺序也没有影响，可以认为$k_1 \geq k_2 \cdots \geq k_l$.</p>
<p>根据上面的讨论, 只需要对$n &#x3D; 2^{k_1}3^{k_2} \cdots prime_l^{k_l}(k_1 \geq k_2 \cdots \geq k_l)$这样形式的特殊的$n$调用上面的递归式去计算SG(n), 对于其他的$n$,  可以将先$n$求一个”最小表示”$m$, 满足$SG(n) &#x3D; SG(m)$减少不必要的计算。</p>
<p>经程序验证$10^{7}$以内满足上面的形式的特殊的$n$不超过500个，利用前面的性质，我的程序可以在3s内计算出$SG(1 \cdots 10^{7})$, 并且还有一个重要发现是$SG(n) \leq 40(n \leq 10^7)$.</p>
<p>求出了$SG(1 \cdots 10^{7})$之后，问题转化为方程$SG(x_1) \text{ xor }SG(x_2) \text{ xor } \cdots \text{ xor }SG(x_{10^{12}}) &#x3D; 0$的解的数量，因为$SG(x_i) \leq 40$, 左式是一堆$\leq 40$的值异或起来, 因此不会超过$64$. 可以用动态规划解决。</p>
<p>$f_{i, v}$确定完前$i$个变量的值使得等式左边的值是$v$的方案数，令$count_v$表示$SG(n) &#x3D; v$的方案数。转移方程如下:</p>
<p>$$<br>f_{i, v} &#x3D; \sum\limits_{v’}{count_{v \text{ xor } v}f_{i-1,  v’}}<br>$$<br>虽然$v \lt 64$, 但是$i $最大可以到$10^{12}$, 直接计算的话，无论空间还是时间都不够。</p>
<p>优化：</p>
<p>把$f_i$看成一个$64$维列向量，转移方程可以用矩阵来表示:$f_i &#x3D; Af_{i-1}$, 转移矩阵$A_{i, j} &#x3D; count_{i \mathop{xor} j}$:</p>
<p>$f_{n} &#x3D; A^nf_0$, 可以用矩阵快速幂在$O(M^3 \ log N)$的时间内计算出$f_n$。</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> sg[MAXN];</span><br><span class="line"><span class="type">int</span> p[MAXN], flag[MAXN], minPrime[MAXN];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">987654321</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!flag[i]) p[++p[<span class="number">0</span>]] = i, minPrime[i] = i; </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p[<span class="number">0</span>] &amp;&amp; i * p[j] &lt;= lim; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			flag[i*p[j]] = <span class="number">1</span>;</span><br><span class="line">			minPrime[i*p[j]] = p[j];</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matmul</span><span class="params">(LL A[M][M], LL B[M][M], LL C[M][M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL ret[M][M];</span><br><span class="line">	<span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="built_in">sizeof</span>(ret));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; M; ++k)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">				ret[i][j] = (ret[i][j] + A[i][k]*B[k][j]) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">			C[i][j] = ret[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(LL a[M][M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%10lld&quot;</span>, a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>, cnt[M<span class="number">+1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">getPrimes</span>(<span class="number">10000000</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">2</span>; n &lt;= <span class="number">10000000</span>; ++n)</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; exps;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = n, pr, c; v != <span class="number">1</span>; )</span><br><span class="line">		&#123;</span><br><span class="line">			pr = minPrime[v];</span><br><span class="line">			c = <span class="number">0</span>; </span><br><span class="line">			<span class="keyword">while</span> (minPrime[v] == pr)</span><br><span class="line">				  v /= pr, ++c;</span><br><span class="line">	        exps.<span class="built_in">push_back</span>(c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(exps.<span class="built_in">begin</span>(), exps.<span class="built_in">end</span>());</span><br><span class="line">		<span class="type">int</span> _n = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = exps.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; exps[i]; ++j)</span><br><span class="line">				_n *= p[exps.<span class="built_in">size</span>()-i];</span><br><span class="line">		<span class="built_in">assert</span>(_n &lt;= n);</span><br><span class="line">		<span class="keyword">if</span> (_n != n) sg[n] = sg[_n];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++num;</span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; divisors;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> d=<span class="number">2</span>; d*d &lt;= n; ++d)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (n % d) <span class="keyword">continue</span>;</span><br><span class="line">				divisors.<span class="built_in">push_back</span>(d);</span><br><span class="line">				<span class="keyword">if</span> (d*d != n) divisors.<span class="built_in">push_back</span>(n/d);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> vis[M] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> d1: divisors)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> d2: divisors)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">assert</span>((sg[d1]^sg[d2]) &lt; M);</span><br><span class="line">					vis[sg[d1]^sg[d2]] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">while</span> (vis[sg[n]]) ++sg[n];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">assert</span>(sg[n] &lt; M);</span><br><span class="line">		cnt[sg[n]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">	</span><br><span class="line">	LL initial_vector[M] = &#123;<span class="number">1</span>&#125;, ret[M] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	LL transition_matrix[M][M], final_matrix[M][M] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) </span><br><span class="line">		final_matrix[i][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">			transition_matrix[i][j] = cnt[j^i];</span><br><span class="line"></span><br><span class="line">	LL K = <span class="number">1e12</span>;</span><br><span class="line">	<span class="keyword">for</span> (; K; K &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (K &amp; <span class="number">1</span>) <span class="built_in">matmul</span>(final_matrix, transition_matrix, final_matrix);</span><br><span class="line">		<span class="built_in">matmul</span>(transition_matrix, transition_matrix, transition_matrix);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">			ret[i] = (ret[i] + initial_vector[j]*final_matrix[i][j]) % mod; </span><br><span class="line">	&#125;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; M; ++i)</span><br><span class="line">		ans += ret[i];</span><br><span class="line">	cout &lt;&lt; ans % mod &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/08/07/Stoer%E2%80%93Wagner-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/07/Stoer%E2%80%93Wagner-Algorithm/" class="post-title-link" itemprop="url">Stoer–Wagner Algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-07 10:46:32" itemprop="dateCreated datePublished" datetime="2019-08-07T10:46:32+00:00">2019-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://fktpm.ru/file/204-stoer-wagner-a-simple-min-cut-algorithm.pdf">Download Paper: A Simple Min-Cut Algorithm</a></p>
<h4 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h4><p>将一个带非负边权的无向图$G &#x3D; (V, E)$分成2个非空点集$S, T$, 使得跨过$S, T$的边权值之和尽可能小, 即求<br>$$<br>\mathop{\arg\min}\limits_{S, T}{\sum\limits_{(u,v)\in E \ u\in S, v\in T}{w(u, v)}}<br>$$</p>
<p>以前只学过网络流求$s-t$最小割, 而这个问题要求的是全局的最小割。这篇paper介绍的<strong>Stoer–Wagner Algorithm</strong>其实很早就听说过了，于是趁着暑假看了看。其实算法的思想和过程都非常简单，不过算法的正确性并不是那么显然。</p>
<h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><h5 id="Basic-Idea："><a href="#Basic-Idea：" class="headerlink" title="Basic Idea："></a>Basic Idea：</h5><p>定义$s$-$t$-$cut$为将点$s, t$分别划分到集合$S, T$的一个割。</p>
<p>如果我们能快速找到任意一对顶点$s, t$, 以及其对应的<strong>最小</strong>的$s$-$t$-$cut$(指所有将$s, t$分开的割中权值最小的), 那么可以分以下两种情况:</p>
<ul>
<li>如果存在某个全局最小割，将$s, t$分到了两边, 那么这个$s$-$t$-$cut$就是全局最小割。</li>
<li>全局最小割中，$s, t$一定被分到了同一边，那么可以把这两个点捆绑(合并)起来，使得问题规模减小。</li>
</ul>
<h5 id="Formal-Decription："><a href="#Formal-Decription：" class="headerlink" title="Formal Decription："></a>Formal Decription：</h5><p>主算法流程：</p>
<ol>
<li>找到任意一个$minimum$ $s$-$t$-$cut$, 更新当前答案。</li>
<li>合并点$s, t$： 增加一个新的点$st$, 使得$w(st, u) &#x3D; \sum w(s, u)+\sum w(t, u)$.</li>
<li>从原图上删去$s, t$, 即$G:&#x3D; G \backslash {s, t} \cup {st}$</li>
<li>重复以上过程，直到图只剩下一个点，输出当前答案。</li>
</ol>
<p>关键就在于算法的第1步，找到任意一个最小的$s$-$t$-$cut$。论文提出了下面的子算法:</p>
<ol>
<li>$A :&#x3D; {a}$, $a$是任意选的一个顶点。</li>
<li>选取一个点$v$加入到集合$A$中，满足$v &#x3D; \mathop{\arg \max}\limits_{v \in V \backslash A}{\sum\limits_{a \in A}{w(v,a)}}$， 即$v$是和$A$ most densely connected在的点。</li>
<li>重复上面的过程，直到$V &#x3D;A$.  最后加入$A$的2个顶点就是我们要找的$s,t$，将图分为 ${t}$和$V\backslash {t}$就是我们要找的$minimum$ $s$-$t$-$cut$.</li>
</ol>
<p>虽然看起来挺科学的，但是子算法的正确性至少在我看来并不那么显然。</p>
<h4 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h4><p>主算法正确性显然，因此只需要证明子算法找到的$s$-$t$-$cut$确实是所有将$s, t$分到两边的cut中权值最小的。</p>
<p>为了描述方便，首先引入一些记号：</p>
<ul>
<li>$C$是某个$s$-$t$-$cut$，定义$C:&#x3D;{S, T }$,。</li>
<li>如果运行完子算法，一个顶点$v$和恰好在它之前加入$A$的顶点被$C$分到了两边，那么称$v$是active的(with respect to $C$).</li>
<li>$A_v$表示在$v$之前加入$A$的顶点集合。</li>
<li>$C_v$ 表示${S \cap(A_v\cup {v}), T \cap(A_v\cup {v}}$。 (原论文的表述是<strong>the cut of $A_v \cup {v}$ induced by $C$</strong>)。</li>
</ul>
<p>下面证明所有active的顶点$v$满足$w(A_v, v) \leq w(C_v)$:    </p>
<p>因为$C$是$s$-$t$-$cut$, 所以最后加入$A$的点$t$一定是active的，如果上面的不等式成立，那么有$w(A_t, t) \leq w(C)$, 也就证明了子算法的正确性。</p>
<p>采用归纳法来证明：</p>
<p>首先，第一个active的点, 一定满足上面的式子, 因为$C_v$中，一定是$v$单独一个集合，其它点一个集合。</p>
<p>假设到$v$为止，所有的active vertex都满足上面的不等式。</p>
<p>考虑在$v$后面的第一个active vertex $u$:<br>$$<br>w(A_u, u) &#x3D; w(A_v, u) + w(A_u \backslash A_v, u ) :&#x3D; \alpha<br>$$</p>
<p>因为$v &#x3D; \mathop{\arg \max}\limits_{x}{w(A_v, x)}$, 所以$w(A_v, u) \leq w(A_v, v) \leq w(C_v)$. </p>
<p>又因为$u$是$v$后面第一个active vertex, 所以在$C$中, $v$到$u$之间的点 和 u一定属于不同集合, 那么 contribute to $w(C_u)$，并且not to $w(C_v)$. 综上有:<br>$$<br>w(A_u, u) \leq w(C_v) + w(A_u \backslash A_v, u ) \leq w(C_u)<br>$$</p>
<h4 id="Running-Time"><a href="#Running-Time" class="headerlink" title="Running Time"></a>Running Time</h4><p>子算法可以对每个点维护一个值，表示当前和$A$相连的边的权值和，再随便用一个平衡树、堆之类的数据结构来维护当前与$A$ most densely connected的点, 每次将一个点加入$A$的时候，更新它所有邻居的值。最多迭代$O(|V|)$次, 总时间是$O(|E| + |V| \log |V|)$. 一共调用$O(|V|)$次子算法，总时间就是$O(|E||V| +|V|^2 \log |V|)$</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>手写了一个堆来实现，500个点的完全图大概需要0.7s。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	LL value[MAXN];</span><br><span class="line">	<span class="type">int</span> key_pos[MAXN];</span><br><span class="line">	<span class="type">int</span> pos_key[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="built_in">Heap</span>()&#123;size = <span class="number">0</span>;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> key, LL newv)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		value[++size] = newv;</span><br><span class="line">		key_pos[key] = size;</span><br><span class="line">		pos_key[size] = key;</span><br><span class="line">		<span class="built_in">up</span>(size); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swapnode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		key_pos[pos_key[y]] = x;</span><br><span class="line">		key_pos[pos_key[x]] = y;</span><br><span class="line">		<span class="built_in">swap</span>(pos_key[y], pos_key[x]);</span><br><span class="line">		<span class="built_in">swap</span>(value[y], value[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> father = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (value[father] &gt;= value[x]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in">swapnode</span>(x, father);</span><br><span class="line">			x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> ((x&lt;&lt;<span class="number">1</span>) &lt;= size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k = x;</span><br><span class="line">			<span class="keyword">if</span> (value[x&lt;&lt;<span class="number">1</span>] &gt; value[k]) k = x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> ((x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) &lt;= size &amp;&amp; value[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] &gt; value[k]) k = x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (x == k) <span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in">swapnode</span>(x, k);</span><br><span class="line">			x = k; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">swapnode</span>(<span class="number">1</span>, size);</span><br><span class="line">		size--;</span><br><span class="line">		<span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> pos_key[size<span class="number">+1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        value[key_pos[key]] = v;</span><br><span class="line">		<span class="built_in">up</span>(key_pos[key]);  	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> size == <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Stoer_Wagner</span><span class="params">(<span class="type">int</span> n, LL w[][MAXN])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL ret = <span class="number">1e18</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> deleted[MAXN];</span><br><span class="line">	<span class="type">static</span> vector&lt;<span class="type">int</span>&gt; adj[MAXN];</span><br><span class="line">	<span class="built_in">memset</span>(deleted, <span class="number">0</span>, <span class="built_in">sizeof</span>(deleted));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">			<span class="keyword">if</span> (j != i &amp;&amp; w[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">			   adj[i].<span class="built_in">push_back</span>(j);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> iter = <span class="number">1</span>; iter &lt; n; ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">// find minimum s-t-cut</span></span><br><span class="line">	    </span><br><span class="line">	    LL density[MAXN] = &#123;<span class="number">0</span>&#125;; <span class="comment">// density[u] means sum of weight of edges between u and A</span></span><br><span class="line">		Heap heap;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">		<span class="type">bool</span> inA[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="comment">// find any exixting vertex and add it to A</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (deleted[i]) <span class="keyword">continue</span>; </span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt;= n; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (deleted[j]) <span class="keyword">continue</span>; </span><br><span class="line">			    density[j] = w[i][j];</span><br><span class="line">		        heap.<span class="built_in">push</span>(j, density[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			A.<span class="built_in">push_back</span>(i);</span><br><span class="line">			inA[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// each iter add most densely connected vertex to A</span></span><br><span class="line">		<span class="keyword">while</span> (!heap.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u = heap.<span class="built_in">pop</span>();</span><br><span class="line">			A.<span class="built_in">push_back</span>(u);</span><br><span class="line">			inA[u] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)adj[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> v = adj[u][i];</span><br><span class="line">				<span class="keyword">if</span> (deleted[v] || inA[v]) <span class="keyword">continue</span>;</span><br><span class="line">				density[v] += w[v][u];</span><br><span class="line">				heap.<span class="built_in">modify</span>(v, density[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> s = A[A.<span class="built_in">size</span>()<span class="number">-2</span>], t = A[A.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">		A.<span class="built_in">clear</span>();</span><br><span class="line">		ret = <span class="built_in">min</span>(ret, density[t]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// merge vertex s, t</span></span><br><span class="line">		<span class="comment">// In my implementation, I just make all t&#x27;s edges connected to s, and delete t</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)adj[t].<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> v = adj[t][i];</span><br><span class="line">			<span class="keyword">if</span> (deleted[v] || v == s) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (!w[s][v]) adj[s].<span class="built_in">push_back</span>(v), adj[v].<span class="built_in">push_back</span>(s);</span><br><span class="line">			w[s][v] += w[t][v];</span><br><span class="line">			w[v][s] += w[v][t];</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		deleted[t] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		adj[i].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h4><p>在读论文的时候，我有一个疑惑：子算法每次返回的$minimum$ $s$-$t$-$cut$, 都是 ${t}$和$V\backslash {t}$这样的形式，即一个点一个集合，剩下的所有点一个集合。 那么为什么不直接枚举一个点$t$，让它单独一个集合，剩下的点一个集合，然后取最小的这样的划分呢？</p>
<p>答案是否定的，这样找到的$s$-$t$-$cut$, 不一定满足$minimum$，即不能保证不存在另一种划分$S, T$满足$s\in S, t \in T$权值更小。   只能说根据子算法的证明，一定存在一个$minimum$ $s$-$t$-$cut$是 ${t}$和$V\backslash {t}$这样的形式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/08/05/Project-Euler-Problem-379-Least-common-multiple-count/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/05/Project-Euler-Problem-379-Least-common-multiple-count/" class="post-title-link" itemprop="url">Project Euler Problem 379-Least common multiple count</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-05 22:52:51" itemprop="dateCreated datePublished" datetime="2019-08-05T22:52:51+00:00">2019-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h4><p>求有多少正整数对$(x, y)$满足$x \leq y$并且$x, y$的最小公倍数$\leq 10^{12}$.</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p>为了方便，先去掉$x \leq y$的限制:</p>
<p>设$N &#x3D; 10^{12}$, 那么原问题的答案 &#x3D; (去掉 $x\leq y$的限制后的答案+N) &#x2F; 2.  </p>
<p>枚举$(x, y)$的最大公约数$d$,即$x &#x3D; id, y &#x3D; jd$, 最小公倍数就是$ijd$, 当然还要求$i, j$互质。</p>
<p>令$[expression]$表示当表达式为真的时候是1，否则是0。</p>
<p>$(i, j)$表示$i,j$的最大公约数)。</p>
<p>$h(n) &#x3D; \sum\limits_{i&#x3D;1}\sum\limits_{j&#x3D;1}\lfloor\frac{n}{ij} \rfloor$。</p>
<p>利用莫比乌斯函数容斥去掉$i, j$互质的限制。</p>
<p>要求的就是下面的式子：<br>$$<br>\begin{aligned}<br>answer &amp;&#x3D;\sum\limits_{i&#x3D;1}^{N}\sum\limits_{j &#x3D; 1}^{N}\sum\limits_{d}[(i, j) &#x3D; 1](ijd\leq N) \<br>&amp;&#x3D; \sum\limits_{i&#x3D;1}^{N}\sum\limits_{j &#x3D; 1}^{N}[(i, j) &#x3D; 1]\lfloor\frac{N}{ij} \rfloor \<br>&amp;&#x3D; \sum\limits_{d&#x3D;1}^{N}\mu(d)\sum\limits_{i \geq 1}\sum\limits_{j \geq 1}\lfloor\frac{N}{ijd^2} \rfloor\<br>&amp;&#x3D; \sum\limits_{d&#x3D;1}^{N}\mu(d) h(\lfloor \frac{N}{d^2} \rfloor) \<br>&amp;&#x3D; \sum\limits_{d&#x3D;1}^{\sqrt {N}}\mu(d) h(\lfloor \frac{N}{d^2} \rfloor)<br>\end{aligned}<br>$$</p>
<p>考虑如何算$h(n)$: </p>
<p>令$hh(n) &#x3D; \sum\limits_{i&#x3D;1}^{n}{\lfloor \frac{n}{i}\rfloor}$。<br>$$<br>\begin{aligned}<br>h(n) &amp;&#x3D;  \sum\limits_{i\geq 1}\sum\limits_{j\geq 1}\lfloor\frac{n}{ij} \rfloor \<br>&amp;&#x3D; \sum\limits_{i&#x3D;1}^{n}{hh(\lfloor \frac{n}{i}\rfloor)}<br>\end{aligned}<br>$$</p>
<p>$hh(n)$可以在$O(\sqrt n)$的时间内计算(根据$\lfloor \frac{n}{i} \rfloor$只有$O(\sqrt n)$种不同的取值分段计算)。</p>
<p>同理, $h(n)$也可以根据$\lfloor \frac{n}{i} \rfloor$的值分段计算, 复杂度是$O(n^{\frac{3}{4}})$.</p>
<p>复杂度推导:</p>
<ul>
<li><p>当$i \geq \sqrt n$的时候,  $\lfloor \frac{n}{i} \rfloor \leq \sqrt n$, 对时间复杂度的贡献不超过$\sum\limits_{i&#x3D;1}^{\sqrt n}{O(\sqrt i)}$, $\sum\limits_{i&#x3D;1}^{\sqrt n }{\sqrt i} \leq  \int\limits_{1}^{\sqrt n + 1}{\sqrt x \ dx} &#x3D; O(n^{\frac{3}{4}})$</p>
</li>
<li><p>当$i \lt \sqrt n$的时候,  对时间复杂度的贡献不超过$\sum\limits_{i&#x3D;1}^{\sqrt n}{O(\sqrt {\frac{n}{i}})}$,  $\sum\limits_{i&#x3D;1}^{\sqrt n}{\sqrt {\frac{n}{i}}} \leq \int\limits_{0}^{\sqrt n}{\sqrt{\frac{n}{x}} dx} &#x3D; O(n^{\frac{3}{4}})$</p>
</li>
</ul>
<p>因此总复杂度是$O(n^{\frac{3}{4}})$.</p>
<p>计算总答案$answer &#x3D;\sum\limits_{d&#x3D;1}^{\sqrt {N}}\mu(d) h(\lfloor \frac{N}{d^2} \rfloor)$的复杂度：<br>$$<br>\begin{aligned}<br>\sum\limits_{d&#x3D;1}^{\sqrt {N}}{(\frac{N}{d^2})^{\frac{3}{4}}} &amp;&#x3D; N^{\frac{3}{4}} \sum\limits_{d&#x3D;1}^{\sqrt {N}}{d^{-\frac{3}{2}}} \<br>&amp;\leq N^{\frac{3}{4}} \int\limits_{0}^{\sqrt N}{x^{-\frac{3}{2}} dx} \<br>&amp;&#x3D; O(N^{\frac{3}{4}})<br>\end{aligned}<br>$$</p>
<h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation:"></a>Implementation:</h4><p>在我的机子上大约需要跑5min。<br>可以通过预处理函数$hh(1\cdots 10^6)$来加速，不过加上这个优化之后我就不太会分析复杂度…不过效果还是很好的, 实测加上之后只需要跑1min左右。<br>以下代码是不加优化的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LIM = <span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> flag[LIM], p[LIM], mu[LIM];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">hh</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// can add optimization: if (n &lt; M) return hh[n];</span></span><br><span class="line">	LL ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r = n / (n/l);</span><br><span class="line">		ret += (r-l<span class="number">+1</span>) * (n/l); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">h</span><span class="params">(LL n)</span> <span class="comment">// h(n) = sum(n/ij)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r = n / (n/l);</span><br><span class="line">		ret += (r-l<span class="number">+1</span>) * <span class="built_in">hh</span>(n/l); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; LIM; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!flag[i]) mu[i] = <span class="number">-1</span>, p[++p[<span class="number">0</span>]] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p[<span class="number">0</span>] &amp;&amp; i*p[j] &lt; LIM; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			flag[i*p[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			mu[i*p[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">	</span><br><span class="line"> 	LL n = <span class="number">1e12</span>, ans = <span class="number">0</span>; </span><br><span class="line"> 	<span class="keyword">for</span> (LL d = <span class="number">1</span>; d*d &lt;= n; ++d)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		<span class="keyword">if</span> (!mu[d]) <span class="keyword">continue</span>;</span><br><span class="line"> 		ans += mu[d] * <span class="built_in">h</span>(n/d/d);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	ans = (ans+n) / <span class="number">2</span>;</span><br><span class="line"> 	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="More-Efficient-Solution"><a href="#More-Efficient-Solution" class="headerlink" title="More Efficient Solution:"></a>More Efficient Solution:</h4><p>#### More Efficient Solution:</p>
<p>$h(n) &#x3D; \sum\limits_{i, j \geq 1}{\lfloor \frac{N}{ij} \rfloor}$实际上是在求满足$i,j,k \in Z^+, ijk\leq N$的triple($i$, $j$, $k$)的数量.</p>
<p>分下面3种情况来算:</p>
<p>$ans_1$: $i &lt; j &lt; k$的答案。</p>
<p>$ans_2$: $i&#x3D;j&#x3D;k$的答案.</p>
<p>$ans_3$: $i&#x3D;j\neq k$的答案. </p>
<p>那么根据对称性有$h(n) &#x3D; 6ans_1 + ans_2 + 3ans_3$</p>
<p>计算$ans_1$:</p>
<p>注意到$i \leq  n^{\frac{1}{3}}$, 枚举$i$, 然后对$j$分段, 复杂度是$\sum\limits_{i&#x3D;1}^{n^{\frac{1}{3}}}{\sqrt{\frac{n}{i}}} &#x3D; O(n^{\frac{2}{3}})$</p>
<p>计算$ans_2$:</p>
<p>$ans2 &#x3D; \lfloor \sqrt[3]{n}\rfloor, O(1)$</p>
<p>计算$ans_3$:</p>
<p>$ans_3 &#x3D; \sum\limits_{k&#x3D;1}^{n}{\lfloor \sqrt{\frac{n}{k}} \rfloor} - ans_2 &#x3D; \sum\limits_{k&#x3D;1}^{n}{\lfloor \sqrt{\lfloor \frac{n}{k} \rfloor} \rfloor} - ans_2$ </p>
<p>可以根据$\lfloor \frac{n}{k} \rfloor$的取值分块计算, 复杂度$O(\sqrt n)$.</p>
<p>综上我们可以在$O(n^{\frac{2}{3}})$的时间里计算$h(n)$, 比之前的$O(n^{\frac{3}{4}})$要好一些。</p>
<p>计算总答案的时间就可以优化成:<br>$$<br>\begin{aligned}<br>\sum\limits_{d&#x3D;1}^{\sqrt {N}}{(\frac{N}{d^2})^{\frac{2}{3}}} &amp;&#x3D; N^{\frac{2}{3}} \sum\limits_{d&#x3D;1}^{\sqrt {N}}{d^{-\frac{4}{3}}} \<br>&amp;\leq N^{\frac{2}{3}} \int\limits_{0}^{\sqrt N}{x^{-\frac{4}{3}} dx} \<br>&amp;&#x3D; O(N^{\frac{2}{3}})<br>\end{aligned}<br>$$</p>
<p><strong>Implementation</strong>:<br>我的电脑上运行只需要11s。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int LIM = 1e6+10;</span><br><span class="line">typedef long long LL;</span><br><span class="line">int flag[LIM], p[LIM], mu[LIM];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LL h(LL n) // h(n) = sum(n/ij)</span><br><span class="line">&#123;</span><br><span class="line">	LL ans1 = 0; // i &lt; j &lt; k</span><br><span class="line">	for (LL i = 1; i*i*i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		LL m = n/i;</span><br><span class="line">		// j &lt; [n/ij]</span><br><span class="line">		// j &lt;= n/ij - 1</span><br><span class="line">		// j*(j+1) &lt;= m</span><br><span class="line">		LL lim = sqrt(m);</span><br><span class="line">		while (lim*(lim+1) &gt; m) --lim;</span><br><span class="line">		while ((lim+1)*(lim+2) &lt;= m) ++lim;</span><br><span class="line">		for (LL l = i+1, r, v; l &lt;= lim; l = r+1)</span><br><span class="line">		&#123;</span><br><span class="line">			v = m/l;</span><br><span class="line">			r = m/v;</span><br><span class="line">			ans1 += v*(r-l+1) - (l+r)*(r-l+1)/2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// i=j=k</span><br><span class="line">	LL ans2 = pow(n, 1.0/3);</span><br><span class="line">	while (ans2*ans2*ans2 &gt; n) --ans2;</span><br><span class="line">	while ((ans2+1)*(ans2+1)*(ans2+1) &lt;= n) ++ans2;</span><br><span class="line">	</span><br><span class="line">	// i=j, k != i</span><br><span class="line">	LL ans3 = -ans2;</span><br><span class="line">	for (LL l = 1, r, v; l &lt;= n; l = r+1)</span><br><span class="line">	&#123;</span><br><span class="line">		v = n/l;</span><br><span class="line">		r = n/v;</span><br><span class="line">		ans3 += (r-l+1)* (LL)sqrtl(v);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 6*ans1 + ans2 + 3*ans3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	mu[1] = 1;</span><br><span class="line">	for (int i = 2; i &lt; LIM; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!flag[i]) mu[i] = -1, p[++p[0]] = i;</span><br><span class="line">		for (int j = 1; j &lt;= p[0] &amp;&amp; i*p[j] &lt; LIM; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			flag[i*p[j]] = 1;</span><br><span class="line">			if (i % p[j] == 0) break;</span><br><span class="line">			mu[i*p[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">	</span><br><span class="line"> 	LL n = 1e12, ans = 0; </span><br><span class="line"> 	for (LL d = 1; d*d &lt;= n; ++d)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		if (!mu[d]) continue;</span><br><span class="line"> 		ans += mu[d] * h(n/d/d);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	ans = (ans+n) / 2;</span><br><span class="line"> 	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/08/01/Approximation-Algorithm-4-The-Set-Cover-Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/01/Approximation-Algorithm-4-The-Set-Cover-Problem/" class="post-title-link" itemprop="url">Approximation Algorithm(4)-The Set Cover Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-01 16:46:18" itemprop="dateCreated datePublished" datetime="2019-08-01T16:46:18+00:00">2019-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Week 4: The Set Cover Problem</strong></p>
<h4 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h4><p>定义元素的集合$E &#x3D; {e_1, e_2 \cdots e_n }$, 给出$m$个集合${S_i \subseteq U }$, 且$\bigcup\limits_{i&#x3D;1}^{m}{S_i} &#x3D; E$。  选取第$i$个集合需要代价$c_i$, 求集合$I$, 满足$\bigcup\limits_{i \in I}{S_i} &#x3D; E$ 并且 $\sum\limits_{i \in I}{c_i}$最小。<br>容易发现, Week 1讲的Vertex Cover问题是Set Cover问题的一个特例。</p>
<h4 id="Algorithm-with-Linear-Programming"><a href="#Algorithm-with-Linear-Programming" class="headerlink" title="Algorithm with Linear Programming"></a>Algorithm with Linear Programming</h4><ul>
<li>Variables ${x_i }, x_i &#x3D; 1$ if and only $i \in I$.</li>
<li>Constraints: <ul>
<li>For each $e \in E$, $\sum\limits_{e \in S_i}{x_i} \geq 1$.</li>
<li>For each $i$, $0 \leq x_i \leq 1$.</li>
</ul>
</li>
<li>Objective Function: $\sum\limits_{i&#x3D;1}^{m}{c_i x_i}$</li>
</ul>
<h4 id="Algorithm-Base-on-Randomized-Rounding"><a href="#Algorithm-Base-on-Randomized-Rounding" class="headerlink" title="Algorithm Base on Randomized Rounding"></a>Algorithm Base on Randomized Rounding</h4><h5 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h5><p>不同于前几次课LP的Rounding方法, 本周介绍的是Randomized Rounding。<br>基本思想是，根据一定的概率，选择将$x_i$ round成$0$还是$1$。<br>显然我们更应该选取那些$x_i$比较大的集合, 因为$0 \leq x_i \leq 1$, 可以令我们选取第$i$个集合的概率恰好是$x_i$。<br>然而, 这样我们最后选取的集合，不一定能恰好覆盖全集$E$。</p>
<h5 id="Cost-Analysis"><a href="#Cost-Analysis" class="headerlink" title="Cost Analysis"></a>Cost Analysis</h5><p>我们希望知道，期望意义下，我们的算法能覆盖多少元素。<br>考虑某个元素$e$被覆盖的概率：<br>$$<br>\begin{aligned}<br>Pr[e \text{  is  covered}] &amp;&#x3D; 1 - Pr[e \text{ is not covered}] \ &amp;&#x3D; 1-\prod\limits_{e \in S_i}{Pr[S_i \text{ is not picked}]} \ &amp;&#x3D; 1-\prod\limits_{e \in S_i}{(1-x_i)} \<br>&amp;&#x3D; 1-e^{\sum\limits_{e \in S_i}{\ln(1-x_i)}}<br>\end{aligned}<br>$$</p>
<p>当$x \in [0, 1)$时, 有 $ \ln (1-x) \leq -x $.</p>
<p>将上面的式子放缩一下:<br>$$<br>\begin{aligned}<br>Pr[e \text{  is  covered}] &amp;&#x3D; 1-e^{\sum\limits_{e \in S_i}{\ln(1-x_i)}}\<br>&amp;\geq 1-e^{\sum\limits_{e \in S_i}{-x_i}} \<br>&amp;\geq  1-e^{-1} \<br>&amp;\approx 0.63<br>\end{aligned}<br>$$<br>第二行到第三行用到了LP的条件: $\sum\limits_{e \in S_i}{x_i} \geq 1$</p>
<p>根据上面的推导, 容易知道在期望意义下能覆盖差不多63%的点。</p>
<p>于是很自然地可以想到 ，如果多次调用上面的算法，那么可以覆盖更多的点, 因为每次期望能覆盖63%，所以期望意义下不需要重复非常多次。假设重复$T$次, 那么有以下结果:<br>$$<br>\begin{aligned}<br>Pr[\text{is not a cover}|\ T] &amp;\leq \sum\limits_{e}{Pr[e \text{ is not covered}]}\<br>&amp;\leq \sum\limits_{e}{e^{-T}} \<br>&amp;&#x3D; n\cdot e^{-T}<br>\end{aligned}<br>$$<br>如果取$T &#x3D; \ln(n) +3$， 那么有<br>$$<br>Pr[\text{is not a cover}|\ T] \leq \frac{n}{e^{\ln(n)+3}} &#x3D; e^{-3} \lt 0.05<br>$$<br>再来看看总代价, 单次迭代的期望代价是$\sum\limits_{i&#x3D;1}^{m}{c_ix_i} \leq OPT$, 因此总代价的期望$\leq \text{迭代次数}\cdot OPT$</p>
<p>但是我们不想要一个有概率会失败的算法，一个很自然的想法是不断迭代，直到找到一个覆盖为止。同样地，我们需要分析需要迭代的次数大概是怎样的数量级, 以及代价的近似度。</p>
<p>直接分析比较困难，我们考虑算法的另外一个易于分析的等价版本：</p>
<p> <strong>Sample and Iterate Algorithm</strong>:</p>
<ol>
<li>随机选一个集合，选取集合$S_i$的概率是$\frac{x_i}{\sum\limits_{i&#x3D;1}^{m}{x_i}}$。</li>
<li>如果选取的集合还未被加入到答案，把它加入到答案里。</li>
<li>检查是否答案已经构成一个覆盖，如果不是，回到第1步。</li>
</ol>
<p>实际上是对概率做了一个正则化，本质上和之前的算法是一样的，只不过这样好相对分析一些。</p>
<p>算法的分析需要用到新的定理(<strong>Wald’s Equation</strong>)，见下一小节。</p>
<h4 id="Stopping-Time-Analysis"><a href="#Stopping-Time-Analysis" class="headerlink" title="Stopping  Time  Analysis"></a>Stopping  Time  Analysis</h4><p>假设迭代$T$次后找到了一个<strong>cover</strong>, 每次迭代选取的集合代价是${C_1, C_2 \cdots C_T}$, 那么总代价$\text{cost} &#x3D; \sum\limits_{i&#x3D;1}^{T}{C_i}$, 我们希望知道$E[T]$和$E[\text{cost}]$的一些信息。</p>
<p> 注意$E[\text{cost}] &#x3D; E[\sum\limits_{i&#x3D;1}^{T}{C_i}]$, 但是我们不能简单地交换期望和求符号得到$\sum\limits_{i&#x3D;1}^{T}{E[C_i]}$, 因为$T$并不是一个确定的数，而是一个随机变量。</p>
<p>我们可以借助<strong>Wald’s Equation</strong>, <a target="_blank" rel="noopener" href="https://algnotes.info/on/background/stopping-times/walds/">参考资料</a>：</p>
<p><strong>Wald’s Equation</strong>: 如果$T$是stopping time, $X_i \leq c(X_i\text{ is bounded from abount}), E(X_i)\leq \mu$, 那么有$E[\sum\limits_{i&#x3D;1}^{T}{X_i}] \leq \mu E(T)$.</p>
<p>在这个问题中:</p>
<ul>
<li>$C_i \leq \sum c_i$</li>
<li>$E(C_i) \leq \sum\limits_s{Pr[\text{set } s \text{ is chosen in iteration  } i]c_s} &#x3D; \frac{\sum c_i x_i}{\sum x_j} &#x3D; \mu$. 不等号是因为这次迭代可能选了集合$s$但是$s$之前已经被选过了，那么代价应该算成0而不是$c_s$.</li>
</ul>
<p>因此满足Wald’s Equation的条件。</p>
<p>接下来只需要关心$E[T]$的范围，这又需要Wald的另一个定理，<a target="_blank" rel="noopener" href="https://algnotes.info/on/background/stopping-times/walds-dependent/">参考资料</a></p>
<p><strong>Wald’s Equation For Dependent Decrements:</strong></p>
<p>考虑一个递减的随机序列$n_0, n_1 \cdots n_T$, $T$是stopping time。如果存在一个<strong>递增</strong>的函数$f$, 满足$E(n_t-n_{t+1} | n_{t}) \geq f(n_t)$, 那么有$E[T] \leq 1 + E[\int_{n_{T-1}}^{n_0}{\frac{1}{f(z)}dz}]$.</p>
<p>考虑在第$t+1$轮迭代时, 某个还未被覆盖的元素$e$在这轮被覆盖的概率：</p>
<p>$$<br>Pr[e \text{ is coverd}] &#x3D; Pr[\text{some set } S \text{ containing } e \text{ is picked}] &#x3D; \sum\limits_{S \text{ contains } e}{\frac{x_S}{\sum x_j}} \geq \frac{1}{\sum x_j}<br>$$</p>
<p>因此$E(n_t-n_{t+1} | n_{t}) \geq \frac{n_t}{\sum x_j} &#x3D; f(n_t)$满足定理的条件。</p>
<p>利用定理得出:<br>$$<br>\begin{aligned}<br>E[T] &amp;\leq 1 + E[\int_{n_{T-1}}^{n_0}{\frac{\sum x_j}{z}}dz] \<br>&amp;\leq 1 + E[\int_{1}^{N}{\frac{\sum x_j}{z}}dz] \<br>&amp;&#x3D; 1+(\sum x_j) \ln {N}<br>\end{aligned}<br>$$</p>
<p>也就是说我们可以在期望$1+(\sum x_j) \ln {N} $次迭代后找到一个覆盖。</p>
<p>结合$E[\sum\limits_{i&#x3D;1}^{T}{X_i}] \leq \mu E(T)$, $\sum c_i x_i \leq OPT$, 可以得到:<br>$$<br>E[\sum\limits_{i&#x3D;1}^{T}{X_i}] \leq \frac{\sum c_i x_i}{\sum x_j} + \ln N \sum c_i x_i \leq (\frac{1}{\sum x_j}+\ln N) OPT \leq(1+\ln N) OPT<br>$$</p>
<h4 id="A-Greedy-Combinatorial-Algorithm"><a href="#A-Greedy-Combinatorial-Algorithm" class="headerlink" title="A Greedy Combinatorial Algorithm"></a>A Greedy Combinatorial Algorithm</h4><p>不带权的set cover问题其实很容易想到一个贪心做法：每次迭代选一个能覆盖最多未覆盖元素的集合，直到形成一个cover，关键是如何分析：</p>
<p>考虑第一次迭代的时候, 因为我们选的是最大的集合, 那么它的大小一定不会小于$\frac{n}{OPT}$, 否则用OPT个大小不到$\frac{n}{OPT}$的集合怎么也不可能覆盖$n$个元素。</p>
<p>更一般性地, 设第$i$次迭代选取的集合能覆盖$k_i$个仍未被覆盖的元素, 第$i$次迭代之后未被覆盖的元素个数是$n_i(n_0 &#x3D; n)$, 那么有$k_i \geq \frac{n_{i-1}}{OPT}$.</p>
<p>那么有$n_i &#x3D; n_{i-1} - k_i \leq n_{i-1} - \frac{n_{i-1}}{OPT}$</p>
<p>即<br>$$<br>\frac{n_i}{n_{i-1}} \leq 1-\frac{1}{OPT}<br>$$<br>那么有<br>$$<br>n_{T}\leq n\cdot(1-\frac{1}{OPT})^{T}<br>$$<br>令右边的式子小于1, 就可以推出$n_T &#x3D; 0$.<br>$$<br>\begin{aligned}<br>&amp;\ \ \ \ \ \ \ n\cdot(1-\frac{1}{OPT})^{T} \lt 1\<br>&amp;\rightarrow \frac{1}{n}\gt(\frac{OPT-1}{OPT})^{T} \<br>&amp;\rightarrow n \lt (\frac{OPT}{OPT-1})^{T} \<br>&amp;\rightarrow  \ln n \lt T \ln(1+\frac{1}{OPT-1}) \leq \frac{T}{OPT-1} \<br>&amp;\rightarrow T \gt (OPT-1)\ln n<br>\end{aligned}<br>$$</p>
<p>也就是说迭代不超过$(OPT-1)\ln n$次之后未覆盖的元素个数变成0, 也就得到了一个cover. 并且有结论表面除非P&#x3D;NP, 不存在近似度小于$O(\log n)$的算法。<br><a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~shuchi/courses/880-S07/scribe-notes/lecture03.pdf">参考文献</a></p>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><p><img src="/Approximation-Algorithm-4-The-Set-Cover-Problem/1.png"></p>
<p>考虑Set Cover Problem, $F(i)$表示元素$i$被多少个集合包含, $F &#x3D; \max_i{{F(i)}}$. 设计一个$F$-approximation的算法，时间复杂度是$O(\text{元素个数}\cdot \text{集合个数})$。<br>有点惭愧，这个问题想了好久也没想出来，想到一些贪心策略，但是要么不会证明近似度，要么构造出了反例近似度大于$F$. 主要困难是不知道怎么把$F$用起来，最后还是向google投降了…<a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~shuchi/courses/880-S07/scribe-notes/lecture03.pdf">参考文献</a><br>算法其实很简单：每次迭代选取一个未覆盖的元素，把<strong>全部</strong>能包含它的集合加入答案。<br>分析: 这里最精髓的地方就在于全部集合加入答案，之前自己想到的总是把某种估价下最优的集合加进来，然而都能造出近似比大于F的反例。证明也很简单，几句话就可以说明白(不过我感觉还是不太容易想到的)。定义两个元素$a,b$不相关当且仅当不存在某个集合同时包含了$a$和$b$。如果我们能找到一个元素的集合$S$, 里面的任意两个元素不相关, 称这样的集合为<strong>独立集</strong>。显然至少需要$|S|$个集合才能覆盖$S$中的所有元素。而我们的算法，每次迭代选取的元素，都是和之前选取的元素不相关的，这些元素构成了一个独立集。假设迭代了$T$次, 每次最多把$F$个集合加入答案, 因此最多把$F\cdot T$个集合加入答案。而$T$次迭代找到的$T$个元素，构成大小为$T$的独立集，因此最优解至少是$T$, 近似比就是$F$.<br><strong>Tight Case</strong>: 3个集合{1, 2, 3}, {1}, {2}, 最优解是1，$F&#x3D;2$, 而算法可能会选集合{1}, {1, 2, 3}.</p>
<p>另外这个近似可以也通过线性规划的rounding达到:  把大于等于$\frac{1}{F}$的$x_i$round到1， 证明类似前几节课讲的vertex cover问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/07/28/Approximation-Algorithm-3-The%20Binpacking%20Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/Approximation-Algorithm-3-The%20Binpacking%20Problem/" class="post-title-link" itemprop="url">Approximation Algorithm(3)-The Binpacking Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-28 20:16:22" itemprop="dateCreated datePublished" datetime="2019-07-28T20:16:22+00:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Week 3: The Binpacking Problem</strong></p>
<h4 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition:"></a>Problem Definition:</h4><p>本周讲的问题和上周背包问题有点相似，上周的是给出物品的体积和价值，要装到一个背包里使得价值之和尽可能大。本周的问题是$N$件物品，每件物品有一个体积${s_i}$, 不失一般性地，可以约定${s_i} \leq 1$, 有容量为$1$箱子, 要用尽可能少的箱子容纳所有的物品。</p>
<h4 id="课程内容："><a href="#课程内容：" class="headerlink" title="课程内容："></a>课程内容：</h4><ul>
<li>Next Fit Algorithm: <ul>
<li>Algorithm: 依次考虑每个物品, 如果这个物品能放入当前箱子, 就放入, 否则关闭当前箱子, 打开一个新的箱子放入这个物品。</li>
<li>Approximation Ratio: 把编号相邻的箱子配对, 考虑箱子$2i-1$和箱子$2i$。我们打开了箱子$2i$, 说明箱子$2i-1$里面的物品体积之和加上箱子$2i$里面的第一个物品的体积, 必然是大于$1$的，否则按照算法流程会把那个物品放入箱子$2i-1$. 假设按照算法流程用了$K$个箱子, 装入最后一个箱子的第一个物品编号是$L$. 那么有<br>  $$OPT \geq \lceil \sum\limits_{i&#x3D;1}^{N}{s_i} \rceil \geq \lceil \sum\limits_{i&#x3D;1}^{L-1}{s_i} \rceil$$<br>   因为$$\sum\limits_{i&#x3D;1}^{L-1}{s_i} \gt \lfloor \frac{K}{2} \rfloor$$, $\lfloor \frac{K}{2} \rfloor$是整数，所以<br>   $$\lfloor \frac{K}{2} \rfloor \leq \lceil \sum\limits_{i&#x3D;1}^{L-1}{s_i} \rceil - 1$$<br>   综合一下有<br>   $$\frac{K-1}{2} \leq \lfloor \frac{K}{2} \rfloor \leq OPT-1$$<br>   即<br>   $$K \leq 2OPT-1$$</li>
<li>Tightness: 一个$2OPT-2$的例子: 一共$4n$个物品, 满足$s_{2i-1} &#x3D; \frac{1}{2}, s_{2i} &#x3D; \frac{1}{2n}$. 显然$OPT &#x3D; n+1$, 而Next Fit给出的结果是$2n$.</li>
<li>Special Case: 所有物品的$s_i \lt \frac{1}{3}$. <ul>
<li>Analysis: 当关闭一个箱子的时候(除了最后一个箱子), 这个箱子里面物品体积之和必然$\geq \frac{2}{3}$, 否则还可以接着装物品。 假设用了$K$个箱子, 第一个装入第$K$个的物品编号是$L$, 那么有<br>  $$OPT \gt \sum\limits_{i&#x3D;1}^{N}{s_i} \gt \sum\limits_{i&#x3D;1}^{L-1}{s_i} \geq \frac{2}{3}(K-1)$$<br>  因此<br>  $$K \leq \frac{3}{2}OPT$$</li>
<li>相应地，可以推导所有物品的$s_i \lt \epsilon$的时候,  有$K \leq \frac{1}{1-\epsilon}OPT$。</li>
</ul>
</li>
</ul>
</li>
<li>A very special case: 物品体积较大, 不同的size比较少(large items, few distinct sizes).<ul>
<li>New Definitions:<ul>
<li>Configuration: 指将若干物品装入一个箱子的某种方法。比如往一个箱子中装入2个size为0.2的物品和1个size为0.6的物品。</li>
<li>$A_{c, s}$: configuration $c$中有$A_{c, s}$个size为$s$的物品。</li>
</ul>
</li>
<li>Observation: 假设物品体积的下界是$\epsilon$, 一共有$K$种不同的size, 那么不同configuration的数量$\leq K^{\frac{1}{\epsilon}}$.</li>
<li>Linear Programming:<br>  对每种size $s$, 设有$n_s$个物品, 那么必须有$\sum\limits_{c}{A_{c, s}x_c} \geq n_s$.<br>  目标函数就是$\sum\limits_{c}{x_c}$</li>
<li>Rounding: 求出实数线性规划的解向上取整。</li>
<li>Analysis: 显然求出的解是合法解，而$OPT \geq \sum\limits_{c}{x_c} \geq \sum\limits_{c}{(\lceil x_c \rceil-1)}$, 因此我们求出的解不会比$OPT$多于线性规划变量的个数, 也就是configuration的数目。而configuration的数目$\leq K^{\frac{1}{D}}$。 综上近似解$\leq OPT + K^{\frac{1}{D}}$。</li>
</ul>
</li>
<li>A less special case: 物品体积较大, 不同的size比较多(large items, many distinct sizes)。<ul>
<li>Reduce to previous case: 考虑Rounding， 将物品按size排序， 然后分成若干组，将每组物品的size round成最大的那个。</li>
<li>Adaptive Rounding:<ul>
<li>假设$\min s_i \geq \epsilon$.</li>
<li>将物品按照size从小到大排序。</li>
<li>将物品分组，每组的数目是$G &#x3D; \lfloor N\epsilon^{2}\rfloor$(除了最后最后一组)。</li>
<li>将每组内物品的size全部变成组内最大的。</li>
<li>通过上面LP的方法求出最优解.</li>
</ul>
</li>
<li>Analysis(有些tricky):<br>  显然上面求出的解是合法的，因为将物品的体积变大了能装下，原问题更加可以装下。<br>  引入一种新的rounding：不是将每组内物品的size全部变成组内最大的, 而是变成<strong>上一组物品的最大size</strong>(第一组就全变成0)。为了表示方便，把第一种rounding后的问题表示为$U(up, 向上变大)$, 第二种rounding后的问题表示为$D(down, 向下变大)$.<br>  考虑$D$和$U$的区别, 假设有$K$组物品, $D$的第$2$组物品和$U$的第$1$组物品是一样的, $D$的第$3$组物品和$U$的第$2$组物品是一样的$\cdots$$D$的第$i+1$组物品和$U$的第$i$组物品是一样的($1 \leq i \leq K-2$)。如下图所示：  <img src="/2019/07/28/Approximation-Algorithm-3-The%20Binpacking%20Problem/1.png" class="">
  而$D$的第$1$组物品体积全是$0$, 可以忽略掉。因此$D$和$U$的区别就是$D$的最后一组和$U$的第$K-1, K$组. 而$D$的最后一组其实完全包含在$U$的第$K-1$组里。 综上, 如果忽略$D$的第$1$组, 那么有<br>  $$card(U-D) \leq \lfloor N\epsilon^{2}\rfloor$$<br>  从而容易得出<br>  $$OPT(U) - OPT(D) \leq \lfloor N\epsilon^{2}\rfloor$$<br>  设$O$是原问题, 那么<br>  $$OPT(D) \leq OPT(O) \leq OPT(U)$$<br>  结合上2条, 可以推出<br>  $$OPT(U) \leq OPT(O) + \lfloor N\epsilon^{2}\rfloor$$<br>  因为$\min s_i \geq \epsilon$, 所以有<br>  $$OPT(O) \geq \sum\limits_{i&#x3D;1}^{N}{s_i} \geq N\epsilon$$<br>  进一步推出<br>  $$OPT(U) \leq OPT(O) + \lfloor N\epsilon^{2}\rfloor \leq OPT(O) + \epsilon OPT(O) &#x3D; (1+\epsilon)OPT(O)$$<br>  综上, Adaptive Rounding的近似比是$1+\epsilon$.</li>
</ul>
</li>
<li>General Cases: 去掉物品体积较大的限制。<ul>
<li>Algorithm:<ul>
<li>将体积$\geq \epsilon$的物品, 按照上面的方法做一遍。</li>
<li>剩下的物品按照现有的箱子有空就塞，没空就开新箱子的原则贪心。</li>
</ul>
</li>
<li>Analysis:<br>  如果加入体积较小的物品没有导致需要打开新的箱子，那么<br>  $$output(All) &#x3D; output(Large) \leq (1+\epsilon)OPT(Large) \leq (1+\epsilon)OPT(All)$$<br>  如果开了新的箱子, 那么除了最后一个箱子, 其他箱子里面装的物品体积之和肯定$\gt 1-\epsilon$。那么<br>  $$OPT(All) \gt (1-\epsilon) (output(All)-1)$$<br>  即<br>  $$output(All) \leq \frac{1}{1-\epsilon}OPT(All)$$<br>  因为<br>  $$\frac{1}{1-\epsilon} &#x3D; 1+\epsilon+\epsilon^2+\epsilon^3\cdots$$<br>  所以<br>  $$\frac{1}{1-\epsilon} \geq 1+\epsilon$$<br>  综合一下就是<br>  $$output(All) \leq \frac{1}{1-\epsilon} OPT(All)$$</li>
</ul>
</li>
<li>前沿科技：Narendra Karmarkar和Richard Karp提出了$OPT+O(log^2(OPT))$的算法, Rebecca Hoberg和Thomas Rothvoss改进了算法，做到了$OPT+O(log(OPT))$。</li>
</ul>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><ul>
<li>Execise 1:<ul>
<li>Definition:<ul>
<li>Decision version of Binpacking: 给出$K$个背包, 问能不能装下所有物品。</li>
<li>Partition Problem:</li>
</ul>
  <img src="/2019/07/28/Approximation-Algorithm-3-The%20Binpacking%20Problem/2.png" class="">
<p>  Theorem: Partition Problem is NP-complete.</p>
</li>
<li>Q1: 证明Binpacking问题的Decision version是NP-complete。<ul>
<li>Idea: 证明Partition Problem可以规约到Binpacking问题的Decision version。</li>
<li>Proof: 构造一个Binpacking问题的instance: $K&#x3D;2, s_i &#x3D; \frac{2a_i}{\sum\limits_{i&#x3D;1}^{n}{a_i}}$, 容易证明发现一个Partition相当于找到一个将这些物品装入2个箱子的解。</li>
</ul>
</li>
<li>Q2: 证明Binpacking不存在$\alpha-approximation(\alpha \lt \frac{3}{2})$, 除非$P &#x3D; NP$.<ul>
<li>反证：假设存在一个$(\frac{3}{2}-\epsilon)-approximation$, 任意Partition Problem的instance $I_P$可以用Q1的方法，构造出一个对应的Binpacking的instance $I_B$, 显然$OPT(I_B) \geq 2$. 要回答$I_P$是不是yes, 实际上就是问$OPT(I_B)$是不是等于$2$。</li>
<li>如果$OPT(I_B) &#x3D; 2$, 那么$(\frac{3}{2}-\epsilon)-approximation$的$output(I_B) \leq 3-2\epsilon \lt 3$, 那么必然有$output(I_B) &#x3D; 2$. </li>
<li>如果$OPT(I_B) \geq 3$, 那么$output(I_B) \geq 3$. </li>
<li>因此只要判断$output(I_B)$是不是等于$2$, 就可以知道$OPT(I_B)$是不是等于$2$, 从而也就知道$I_P$的答案是不是yes.</li>
</ul>
</li>
</ul>
</li>
<li>Exercise 2:<ul>
<li>Problem: 证明Binpacking的FFD(First-Fit Decreasing)算法的结果不会超过$\frac{3}{2}OPT$。</li>
<li>FFD Algorithm: 将物品按size从大到小排序后用First-Fit原则放入箱子。</li>
<li>Proof: 这个问题是目前为止的习题中想的最久的…题目的$\frac{3}{2}$还是有点提示性的。<br>  考虑最后一个箱子的第一个物品, 假设它的编号是$L$。<ul>
<li>如果$s_L \leq \frac{1}{3}$, 因为除了最后一个箱子，前面的每个箱子都装不下它，所以前面的每个箱子里面装的体积都$\gt \frac{2}{3}$，从而有<br>  $$OPT \geq \sum\limits_{i&#x3D;1}^{N}{s_i} \gt \sum\limits_{i&#x3D;1}^{L-1}{s_i} \gt \frac{2}{3}(output(FFD)-1)$$<br>  即<br>  $$output(FFD) \leq \frac{3}{2}OPT$$</li>
<li>如果$s_L \gt \frac{1}{3}$, 那么对任意$i \leq L$, $s_i \gt \frac{1}{3}$。也就是说前$L$个物品, 一个箱子最多只能装2个。此时问题等价于：让尽可能少的物品独占一个箱子，即将尽可能多的物品配对装到箱子里。可以证明，在这个情境下, FFD的结果就是最优解, 即$output(FFD) &#x3D; OPT$.证明如下：<ul>
<li>脑补一下, FFD的过程等价于：<ol>
<li>将 ${s_i}$ 从大到小排序.</li>
<li>$S :&#x3D; {1, 2, \cdots n}$.</li>
<li>找到最小的$j \in S$,满足存在$k \in S, i \lt j, s_k+s_j \leq 1$(如果不存在，跳到第5步), 设$i$是满足条件的最小的$k$, 把物品$i$和$j$装入一个箱子里。</li>
<li>$S :&#x3D; S$ \ ${i}$ \ ${j}$. 跳到第3步。</li>
<li>剩下的$S$中的物品都无法配对了，每个物品单独一个箱子。</li>
</ol>
</li>
<li>证明上面的过程得到是最优解。只要证明对于每次第3步找到的$i, j$, 一定存在某个最优解，$i,j$在一个箱子里面。考虑某个最优解，$i, j$不会都在单独的箱子里，否则把它们装在一起可以少一个箱子。分以下几种情况讨论:<ul>
<li>$i$和$k$装在一起, $j$单独一个箱子: 交换一下$k, j$的位置，还是一个最优解，且包含$i,j$在一个箱子。 </li>
<li>$i$单独一个箱子, $j, k$装在一起: 交换$i, k$的位置。</li>
<li>$i, j$装在一起: 这恰好是我们想要的。 </li>
<li>$i, p$装在一起, $j, q$装在一起: 根据第3步$i$的最小性有$p \gt j$. 那么$s_p+s_q \leq s_j+s_q \leq 1$, 所以$i, j$一个箱子，$p, q$一个箱子也是一个最优解。</li>
</ul>
</li>
</ul>
</li>
<li>综上, $output(FFD) \leq \frac{3}{2}OPT$.</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://ac.informatik.uni-freiburg.de/lak_teaching/ws11_12/combopt/notes/bin_packing.pdf">Another proof from online</a>: 有点巧妙, 比我的要简练得多。<br>  假设FFD用了$K$个箱子, 考虑第$L &#x3D; \lceil \frac{2}{3}K\rceil$个箱子。<ul>
<li>Case 1: 第$L$个箱子中，含有体积$\gt \frac{1}{2}$的物品。那么可以知道, 前$L$个箱子里，都含有一个体积大于$\frac{1}{2}$的物体。因此<br>$$OPT \geq L &#x3D; \lceil \frac{2}{3}K\rceil \geq \frac{2}{3} K$$<br>即<br>$$K \leq \frac{3}{2} OPT$$</li>
<li>Case 2: 第$L$个箱子中，不含有体积$\gt \frac{1}{2}$的物品, 容易推出第$L$至$K-1$个箱子里面至少都有2个物品, 也就是说第$L$至$K$个箱子里面一共至少有$2(K-L)+1$个物品, 并且这些物品都没法放入前$L-1$个箱子。接下来就是最巧妙的一步:<br>把这些物品和前面的箱子配对，一个物品和一个箱子配对，一共可以产生$\min{2(K-L)+1, L-1}$对, <strong>每对物品和其配对的箱子里的物品体积之和大于$1$</strong>, 所以可以推出:<br>$$<br>  \begin{aligned}<br>  \sum\limits_{i&#x3D;1}^{N}{s_i} &amp;\gt \min{2(K-L)+1, L-1} \<br>  &amp;&#x3D; \min{2(K-\lceil \frac{2}{3}K\rceil)+1, \lceil \frac{2}{3}K\rceil -1} \<br>  &amp;\geq  \min{2(K- \frac{2K+2}{3})+1, \lceil \frac{2}{3}K\rceil -1} \<br>  &amp;&#x3D;  \min{\frac{2K}{3} -\frac{1}{3}, \lceil \frac{2}{3}K\rceil -1} \<br>  &amp;&#x3D; \lceil \frac{2}{3}K\rceil -1<br>  \end{aligned}<br>$$<br>  即<br>  $$OPT \geq \lceil \frac{2K}{3} \rceil \geq \frac{2K}{3}$$<br>  从而得出<br>  $$K \leq \frac{3}{2}OPT$$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总结与心得："><a href="#总结与心得：" class="headerlink" title="总结与心得："></a>总结与心得：</h4><ul>
<li>Next-Fit: 通过相邻的bin内部物品体积之和大于1证明$output \leq 2OPT-1$.</li>
<li><strong>学会通过分析一些special cases，来得出general case的solution</strong>。<ul>
<li>物品规模较小的时候($\leq \epsilon$)，利用每个bin内部体积之和$\gt 1-\epsilon$来证明近似比。</li>
<li>物品规模较大的时候($\gt \epsilon$), 可以利用的性质有:<ul>
<li>configuration较少, 利用线性规划。</li>
<li>一些物品不能同时放入一个箱子(比如有$K$个物品体积大于$\frac{1}{2}$, 那么至少需要$K$个箱子来装他们)，得出OPT的一个下界。</li>
</ul>
</li>
</ul>
</li>
<li>Adaptive Rounding: <ul>
<li>将物品分组的思想。</li>
<li>证明近似比的时候，将2种rounding方法联系起来。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/07/27/Approximation-Algorithm-2-Knapsack-Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/Approximation-Algorithm-2-Knapsack-Problem/" class="post-title-link" itemprop="url">Approximation Algorithm(2)-The Knapsack Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-27 18:36:41" itemprop="dateCreated datePublished" datetime="2019-07-27T18:36:41+00:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Week 2: The Knapsack Problem</strong> </p>
<h4 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition:"></a>Problem Definition:</h4><p>$N$件物品，每件物品有一个体积${s_i}$和价值${v_i}$, 现在有一个容量是$B$的背包，要选一些物品装进背包，使得价值之和最大。约定不会有体积超过背包容积的物体。</p>
<h4 id="已有知识："><a href="#已有知识：" class="headerlink" title="已有知识："></a>已有知识：</h4><p>各种背包问题的动态规划做法。</p>
<h4 id="课程内容："><a href="#课程内容：" class="headerlink" title="课程内容："></a>课程内容：</h4><ul>
<li><strong>Special Case 1</strong>：物品的体积等于价值. 也就是说，要将背包装得尽可能满。<br>  贪心做法： 按体积从大到小选。因为有物品装不进背包的时候，背包至少是half-full的，所以近似度是2.</li>
<li><strong>Special Case 2</strong>: 物品价值都比较小. 考虑动态规划，$dp[i][v]$表示考虑前i个物品，拼出价值$v$，需要的最少体积。</li>
<li>当物品价值较大的时候，考虑做一个Scaling。将所有物品的价值乘上一个放缩系数$\alpha$，下取整后，再做动态规划。<br>  <strong>Analysis</strong>:<br>  设放缩后的最优解集合是$I$, 实际最优解集合是$I^{*}$<br>  根据放缩的方法有$v_i’ &#x3D; \lfloor \alpha v_i \rfloor$, $I^{*}$是最优解，所有又有$\sum\limits_{i \in I}{v_i’} \geq \sum\limits_{i \in I^{*}}{v_i’}$<br>  因为$I$是放缩后的最优解，所以有$\sum\limits_{i \in I}{\lfloor \alpha v_i \rfloor} \geq \sum\limits_{i \in I^{*}}{\lfloor \alpha v_i \rfloor}$<br>  因此有$\sum\limits_{i \in I}{\alpha v_i} \geq \sum\limits_{i \in I}{\lfloor \alpha v_i \rfloor} \geq \sum\limits_{i \in I^{*}}{\lfloor \alpha v_i \rfloor}  \geq \sum\limits_{i \in I^{*}}{(\alpha v_i - 1)}  \geq \sum\limits_{i \in I^{*}}{\alpha v_i} - N &#x3D; \alpha OPT - N$<br>  即$\sum\limits_{i \in I}{v_i} \geq OPT - \frac{N}{\alpha}$<br>  如果我们把原来的最大价值$\max{v_i}$放缩到$M$($M &#x3D; \alpha \max{v_i}$), 则$\alpha &#x3D; \frac{M}{\max{v_i}}$<br>  所有有$\sum\limits_{i \in I}{v_i} \geq OPT - \frac{N \max{v_i}}{M}$.<br>  因为约定不会有体积超过背包容量的物体，所以$OPT \geq \max{v_i}$.<br>  进一步放缩:$\sum\limits_{i \in I}{v_i} \geq OPT - \frac{N \max{v_i}}{M} \geq OPT - \frac{N}{M} OPT$.<br>  综上得到$\sum\limits_{i \in I}{v_i} \geq (1-\frac{N}{M})OPT$<br>  如果令$M &#x3D; 100N$，那么就有$\sum\limits_{i \in I}{v_i} \geq 0.99OPT$。<br>  动态规划的时间复杂度是$O(N^2M)$, 可以通过取合适的$M$获得效率和近似比的一个trade off。</li>
</ul>
<h4 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h4><ul>
<li>Q1：分析如下背包问题算法：<ol>
<li>将物品按价值密度$\frac{v_i}{s_i}$从大到小排序。</li>
<li>找到最小的$L$，使得$\sum\limits_{i&#x3D;1}^{L-1} {s_i} \leq B,  \sum\limits_{i&#x3D;1}^{L}{s_i} \gt B$</li>
<li>选前$L-1$个物品，或者只选第$L$个物品，这两种方案取较优者。</li>
</ol>
<ul>
<li><strong>Approximation Radio</strong>：<br>  感觉第三步选取两种方案的较优者是点睛之笔。<ul>
<li>$W &#x3D; max(\sum\limits_{i&#x3D;1}^{L-1} {v_i}, v_L ) \geq \frac{1}{2} \sum\limits_{i&#x3D;1}^{L} {v_i}$。</li>
<li>因为选的是价值密度最大的$L$个，这$L$个物品体积加起来又超过了背包容量$B$, 所以有$\sum\limits_{i&#x3D;1}^{L} {v_i} \gt OPT$。这一步感觉挺显然的，但是水平有限，我给不出很严谨的证明：可以从积分的角度来想，物品的价值和可以表示为$\int_{0}^{B}density(t)dt$，而这种方案使得对任意$t，density(t)$都是最大的.</li>
<li>综上可以得出$max(\sum\limits_{i&#x3D;1}^{L-1} {v_i}, v_L ) \geq \frac{1}{2} OPT$.</li>
<li>ps: 原题是要证明当物品个数趋于无穷多的时候近似比是2，但我的证明似乎和物品个数无关。。。</li>
</ul>
</li>
<li><strong>Tightness</strong>.<br>  比如3个物品，体积分别是$\frac{B}{2}+1, \frac{B}{2}, \frac{B}{2}$, 密度分别是$1+\epsilon, 1, 1$<br>  按照该算法，会选第一个物品，总价值是$(\frac{B}{2}+1)(1+\epsilon)$,  而如果选第2和第3个物品， 可以获得$B$的价值。<br>  比一下是$(\frac{1}{2}+\frac{1}{B}) * (1+\epsilon)$, 当$B$趋向于无穷$\epsilon$趋向于无穷小的时候，会达到$\frac{1}{2}$.</li>
</ul>
</li>
<li>Q2: 一个简单的动态规划题, 没啥好讲的。</li>
</ul>
<h4 id="互评作业："><a href="#互评作业：" class="headerlink" title="互评作业："></a>互评作业：</h4><ul>
<li><strong>Problem</strong>： 假设背包问题允许将物品切成小块放入背包，证明如果按价值密度$\frac{v_i}{s_i}$从大到小选取物品, 一定能达到最优解。</li>
<li><strong>Proof</strong>： 比较显然，只要证明不论什么时候，选取当前剩余物品中价值密度最大的一定最优。 用反证法：假设最优解不取当前价值密度最大的物品$a$，那么一定取了另一个价值密度比较小的物品$b$。把少量的$b$换成$a$可以获得更大的价值, 导致矛盾。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/07/26/Approximation-Algorithm-1-Vertex-Cover/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/26/Approximation-Algorithm-1-Vertex-Cover/" class="post-title-link" itemprop="url">Approximation Algorithm(1)-Vertex Cover</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-26 16:27:55" itemprop="dateCreated datePublished" datetime="2019-07-26T16:27:55+00:00">2019-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>前言</strong><br>最近开始学习近似算法，在Coursera上找到了一门课：<a target="_blank" rel="noopener" href="https://www.coursera.org/learn/approximation-algorithms-part-1/home/welcome">地址</a>。<br>在此按照课程每周的内容，各写一篇blog来总结、分享。</p>
<p><strong>Week 1: Vertex Cover</strong></p>
<h4 id="Problem-Definition："><a href="#Problem-Definition：" class="headerlink" title="Problem Definition："></a>Problem Definition：</h4><p>最小点覆盖，即给出一个无向图，求一个最小的点集$S$，使得每条边都至少有一个顶点在这个点集里。</p>
<h4 id="已有知识："><a href="#已有知识：" class="headerlink" title="已有知识："></a>已有知识：</h4><ol>
<li>树的最小点覆盖很容易用$O(|V|)$的时间求出:</li>
<li>动态规划：$dp[v][0&#x2F;1]$ 表示，最少需要多少个点来覆盖以$v$为根的子树，第二维$0&#x2F;1$表示$v$和它父亲节点之间的边是否已经被覆盖, 转移考虑点$v$选还是不选，从子树的结果转移即可。</li>
<li>贪心：从叶子节点考虑，每个叶子节点和它父亲的边必须要被覆盖，为了覆盖这条边，显然选叶子节点不如还选它的父亲。所以只要将节点按深度从大到小排序，依次考虑，如果当前节点和它父亲之间的边未被覆盖，就选择它的父亲。</li>
<li>算法与数据结构课上讲到的local search的方法。</li>
</ol>
<h4 id="课程内容："><a href="#课程内容：" class="headerlink" title="课程内容："></a>课程内容：</h4><ul>
<li><p>一般图的最小点覆盖是NP-Hard的，证明留坑。</p>
</li>
<li><p>点覆盖问题转整数线性规划：</p>
<ul>
<li>$|V|$个$0&#x2F;1$变量,对应每个点选还是不选，$|E|$个条件，表示每条边必须被覆盖，目标函数是$\sum x_i$, 如果每个点带点权，则应是$\sum w_i x_i$.</li>
<li>如何用一个不等式来表示某条边必须被覆盖？ 假设某条边的端点分别是$u$和$v$， 对应条件$x_u + x_v \geq 1$， 即$x_u, x_v$至少有一个是$1$.</li>
<li>遗憾的是，整数线性规划并没有多项式算法，不过实数线性规划存在多项式算法。</li>
</ul>
</li>
<li><p>近似算法：</p>
<ul>
<li><strong>Idea</strong>：放宽条件，允许$x_i$不是整数，但需要满足$x_i \in [0, 1]$. 在该条件下用实数线性规划的做法，求出最优解$X’$，将该最优解通过某种办法改造成原线性规划问题的最优解 $X$.</li>
<li><strong>Solution</strong>:  把实数线性规划的解做一个“四舍五入”， 即令$x_i &#x3D;  [x_i’  \geq 0.5]$.</li>
<li><strong>Proof of Correctness</strong>:  我们还需要证明，得到的解确实是一个点覆盖，即对于任意边$(u, v)$, 需要满足 $x_u + x_v \geq 1$. 证明很简单，因为$x_u’ + x_v’ \ge 1$, 那么$x_u’, x_v’$至少有一个$\geq 0.5$, 所以$x_u, x_v$至少有一个是$1$.</li>
<li><strong>Approximation Ratio</strong>: 一个重要的性质是$x_i \leq 2x_i’$.  因此 $W(X) \leq 2W(X’) $. 而$X’$是放宽条件之后的最优解，肯定不会大于原问题的最优解，所以有$W(X) \leq 2W(X’) \leq 2OPT$.因此$Appromation ; ratio &#x3D; 2.$</li>
<li><strong>Tightness</strong>: 首先考虑一个四元环，每个点的点权相等，显然最优解只需要用2个点。 然而用实数线性规划得到的一个最优解会是$x_1’ &#x3D; x_2’ &#x3D; x_3’ &#x3D; x_4’ &#x3D; 0.5$, 四舍五入之后$x_1 &#x3D; x_2 &#x3D; x_3 &#x3D; x_4 &#x3D; 1$. 是最优解的2倍。</li>
</ul>
</li>
</ul>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题:"></a>练习题:</h4><p>官方没有提供答案，以下是我个人答案：</p>
<ul>
<li>习题1.  分析下面的点覆盖算法：  <img src="/2019/07/26/Approximation-Algorithm-1-Vertex-Cover/1.png" class="">
<ul>
<li><strong>Algorithm</strong>: 求出图的一个极大匹配, 然后把匹配边的2个端点都加入点覆盖的集合$S$。</li>
<li><strong>Proof of Correctness</strong>： 只要证明每条边都会被求出的点集覆盖。假设某条边没被覆盖，那么这条边的两个端点都是未配点，那么把这条边加入匹配可以让匹配数+1，与极大匹配矛盾。</li>
<li><strong>Appromation Ratio</strong>： 因为匹配边之间没有公共点，所以$OPT \geq 匹配数 &#x3D; \frac{1}{2}|S|$， 即$|S| \leq 2 OPT$。</li>
<li><strong>Tightness</strong>: 考虑一个四元环，最大匹配数是2，因此求出的点集大小是4， 而最优解显然是2，恰好是2倍关系。</li>
</ul>
</li>
<li>习题2：  <img src="/2019/07/26/Approximation-Algorithm-1-Vertex-Cover/2.png" class="">
<ul>
<li><strong>Algorithm</strong>: 给出一个无向图，要删除最少的点，使得剩下的点构成的图不含三元环。</li>
<li><strong>Linear Program</strong>:  从线性规划的角度考虑，每个点删还是不删对应一个$0&#x2F;1$变量，每个原图中的三元环$(a, b, c)$对应一个条件$x_a +x_b + x_c \geq 1$.</li>
<li><strong>Rounding</strong>: 同样地，考虑把实数解改造成整数解，需要做一个rounding。 显然应该令$x_i &#x3D; [x_i’ \geq \frac{1}{3}]$.</li>
<li><strong>Appromation Ratio</strong>: 类似上面最小点覆盖的证明，$x_i \leq 3x_i’$, 可以推出这样求出的答案不超过最优解的3倍.</li>
<li><strong>Tightness</strong>: 考虑一个三元环，线性规划实数解会求出一个最优解是$x_1’ &#x3D; x_2’ &#x3D; x_3’ &#x3D; \frac{1}{3}$, rounding 一下变成$x_1 &#x3D; x_2 &#x3D; x_3 &#x3D; 1$， 答案是3， 而最优解只要随便删掉1个点就好了，因此3倍的上界是可以达到的。</li>
</ul>
</li>
</ul>
<p>####互评作业：<br>分析下面的算法。</p>
<ul>
<li>补充知识: <ul>
<li><strong>Lemma</strong>: 最小点覆盖问题的实数线性规划，一定存在某个最优解，任意$x_i$满足$x_i \in {0, \frac{1}{2}, 1}$ (<strong>Half Integrality</strong>)。   </li>
<li><strong>Proof</strong>：<br>  只要证明任意最优解一定可以调整为上面的形式。假设求出一个最优解是${x_i}$.<br>  取足够小的$\epsilon$, 构造新的解${y_i}$：<br>  $$\begin{equation}<br>  y_i &#x3D; \left{<br>  \begin{array}{lr}<br>  x_i, &amp; x_i \in {0, 0.5, 1}\<br>  x_i+ \epsilon, &amp; 0\lt x_i\lt 0.5\<br>  x_i - \epsilon, &amp; 0.5\lt x_i\lt 1 &amp;<br>  \end{array}<br>  \right. \end{equation}$$<br>  以及${z_i}$:<br>  $$\begin{equation} z_i &#x3D; \left{<br>  \begin{array}{lr}<br>  x_i, &amp; x_i \in {0, 0.5, 1}\<br>  x_i - \epsilon, &amp; 0\lt x_i\lt 0.5\<br>  x_i + \epsilon, &amp; 0.5\lt x_i\lt 1 &amp;<br>  \end{array}<br>  \right. \end{equation}$$<br>  check一下容易发现${y_i}, {z_i}$也是线性规划的解。<br>  因为${x_i}$是最优解，所以有$\sum w_ix_i \leq \sum w_iy_i, \sum w_ix_i \leq \sum w_iz_i$<br>  又有$\sum w_iy_i + \sum w_iz_i &#x3D; 2 \sum w_ix_i$.<br>  因此$\sum w_ix_i &#x3D; \sum w_iy_i &#x3D; \sum w_iz_i$, 即${y_i}, {z_i}$也是最优解。<br>  考虑$\epsilon$从0开始不断变大，直到本来不是0,0.5,1的某个变量变成了0,0.5,1， 称这样的操作为一次松弛操作。不断重复这个过程，最终所有变量都会变成0或者0.5或者1.  因为变量一旦变成了0,0.5,1，就再也不会改变它。所以最多只需要重复 $|V|$次松弛操作。<br>  综上，我们可以在多项式时间内把任意最优解改造成任意$x_i$满足$x_i \in {0, \frac{1}{2}, 1}$的形式。</li>
</ul>
</li>
<li>考虑一个可以四染色的图，下面给出一个近似度为$\frac{3}{2}$的点覆盖算法。  <img src="/2019/07/26/Approximation-Algorithm-1-Vertex-Cover/3.png" class="">
<ul>
<li><strong>Algorithm</strong>：<ol>
<li>将图四染色。</li>
<li>做一次实数线性规划，并把解改造成任意$x_i$满足$x_i \in {0, \frac{1}{2}, 1}$的形式。</li>
<li>将所有$x_i &#x3D; 1$的点加入答案集合$S$.</li>
<li>将所有$x_i &#x3D; \frac{1}{2}$的点，按照颜色分类，并按权值和排序。即按颜色分成$V_0^{\frac{1}{2}}, V_1^{\frac{1}{2}}, V_2^{\frac{1}{2}}, V_3^{\frac{1}{2}}$四个集合，满足$W(V_0^{\frac{1}{2}}) \leq W(V_1^{\frac{1}{2}}) \leq W(V_2^{\frac{1}{2}})  \leq W(V_3^{\frac{1}{2}}) $</li>
<li>将$V_0^{\frac{1}{2}}, V_1^{\frac{1}{2}}, V_2^{\frac{1}{2}}$加入答案集合$S$.</li>
</ol>
</li>
<li><strong>Proof of Correctress</strong>：<br>  考虑边$(u, v)$, 有 $x_u+x_v \geq 1$.<ol>
<li>如果$x_u, x_v$有一个为1，那么那个点在$S$中，这条边被覆盖。</li>
<li>如果$x_u, x_v$有一个为0，另一个肯定为1，那么那个点在$S$中，这条边被覆盖。</li>
<li>剩下一种$x_u &#x3D; x_v &#x3D; \frac{1}{2}$的情况。因为它们相邻，所以颜色不同，因此不会都在$V_3^{\frac{1}{2}}$里，所以至少有一个点在$S$中。</li>
</ol>
</li>
<li><strong>Approximation Ratio</strong>：  <img src="/2019/07/26/Approximation-Algorithm-1-Vertex-Cover/4.png" class=""></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhenwei Liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhenwei Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
