<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuzw1998.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Zhenwei&#39;s Blog">
<meta property="og:url" content="https://liuzw1998.github.io/index.html">
<meta property="og:site_name" content="Zhenwei&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhenwei Liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liuzw1998.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

<script type="text/x-mathjax-config">
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
      tags: 'ams'
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  };
</script>

  <title>Zhenwei's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zhenwei's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2025/11/04/duckdb_sorting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/04/duckdb_sorting/" class="post-title-link" itemprop="url">DuckDB 的排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-04 18:00:00" itemprop="dateCreated datePublished" datetime="2025-11-04T18:00:00+00:00">2025-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Database-System/" itemprop="url" rel="index"><span itemprop="name">Database System</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="DuckDB-的排序算法"><a href="#DuckDB-的排序算法" class="headerlink" title="DuckDB 的排序算法"></a>DuckDB 的排序算法</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>在最新发布的 DuckDB v1.4.0 中，作者时隔 4 年再次重新实现了排序算法。在更早的更新中，作者使用了<a target="_blank" rel="noopener" href="https://duckdb.org/2024/03/29/external-aggregation.html">新的内存页布局 (page layout)</a> 并成功应用于 <a target="_blank" rel="noopener" href="https://github.com/duckdb/duckdb/pull/4189">hash join</a> 和 <a target="_blank" rel="noopener" href="https://github.com/duckdb/duckdb/pull/7931">hash aggregation</a> 等算子，以提高内存不足场景下的查询效率。为了<strong>适配新的内存页布局</strong>，作者重新实现了排序算法。</p>
<p>新的排序算法有以下几个优势：</p>
<ul>
<li>显著提升<strong>有序数据</strong>的排序效率（约快10倍），<strong>随机数据</strong>的排序效率也快了近2倍。</li>
<li>针对内存无法容纳的大表查询，<strong>减少了I&#x2F;O和数据的移动</strong>，使得整体排序时间减少到原来的$\frac{1}{3} \sim \frac{1}{2}$。</li>
<li>算法的<strong>多线程并行性</strong>提高：尽管在单线程的场景下性能略微下降，但随着线程数目增多，排序效率获得大幅提升, 并逐渐超过之前版本。</li>
<li>增加实现了 SQL 的 <code>create_sort_key</code> 函数。</li>
</ul>
<p>算法的基本框架仍然基于归并排序，具体实现的主要变化如下：</p>
<ul>
<li>DuckDB 使用固定大小的排序键。在过去版本中，其大小在<strong>执行时</strong>才会被计算。当前版本使用了<strong>新的排序键存储结构</strong>，在<strong>编译时</strong>就可以知道其大小。</li>
<li>使用了标准的256KiB block size（旧版本使用了不定大小的 block size）。通过实现 <code>std::iterator</code> ，允许有序块 (sorted runs) <strong>使用非连续内存</strong>（多个 pages）。这样不仅可以产生<strong>更大的有序块</strong>（用于提高后续步骤的效率），还可以直接调用 C++ 模板库的排序算法。 </li>
<li>有序块的排序<strong>组合使用3种排序算法</strong>（之前仅用基数排序）：先用 <a target="_blank" rel="noopener" href="https://github.com/Morwenn/vergesort">Vergesort</a> 处理（几乎）有序的数据，再用 <a target="_blank" rel="noopener" href="https://github.com/skarupke/ska_sort">Ska Sort</a> （基数排序的变种）将数据按排序键最高 64 位排序&#x2F;划分，最后再使用快速排序 <a target="_blank" rel="noopener" href="https://github.com/orlp/pdqsort">Pattern-defeating quicksort</a>。 </li>
<li>有序块的合并从之前的 <strong>2-way merge</strong> 改为使用 <strong>k-way merge</strong> （k是可配置参数）；将之前的 <strong>2-way merge path</strong> 推广到 <strong>k-way merge path</strong>。在之前的版本中，算法会完全计算出整个排序后的序列；新算法会逐渐计算排序结果的前缀并可以随时终止，这有利于<code>ORDER BY ... LIMIT ...</code>类型的查询。</li>
</ul>
<h4 id="新的内存页布局-page-layout"><a href="#新的内存页布局-page-layout" class="headerlink" title="新的内存页布局 (page layout)"></a>新的内存页布局 (page layout)</h4><p>DuckDB的内存页布局中，每一行可能会存储指向不定长数据（比如字符串）的内存指针。但是当指针指向的数据被写入磁盘后，指向的地址不再有意义，即使数据可能会被重新载入内存，但在内存中的地址也会发生变化。</p>
<p>在过去的版本中，如果数据被写入磁盘，不仅会导致<strong>大量内存指针的重计算</strong>，还需要<strong>手动管理新地址</strong>，容易出错。新版本采用如下图所示的<a target="_blank" rel="noopener" href="https://duckdb.org/2024/03/29/external-aggregation.html">页布局</a>。</p>
<img src="/2025/11/04/duckdb_sorting/layout.svg" class="" title="layout 示意图">


<p>Row Page 会存储额外的 MetaData，用以记录存储实际数据的 Var Page 的地址信息。当对应的 Var Page 被写入磁盘时，指针失效。但当它再次被载入内存的时候，可以快速地通过 MetaData 计算出新的指针地址。该方式的优势是用lazy的方式更新指针（可以通过 MetaData 检查指针是否已失效），减少了指针的重计算。</p>
<h4 id="内存里排序得到有序块-sorted-runs"><a href="#内存里排序得到有序块-sorted-runs" class="headerlink" title="内存里排序得到有序块 (sorted runs)"></a>内存里排序得到有序块 (sorted runs)</h4><h5 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h5><p>新的排序实现<strong>组合使用了3种排序算法</strong>（之前仅用基数排序）。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Morwenn/vergesort">Vergesort</a> 用于检测和合并数据的有序段。当数据几乎有序时（比如时序数据），表现比较好。</li>
<li>如果 Vergesort 没有检测到数据的有序性，转为使用 <a target="_blank" rel="noopener" href="https://github.com/skarupke/ska_sort">Ska Sort</a> （基数排序的变种）将数据按排序键最高 64 位排序&#x2F;分类。</li>
<li>当上面的 Ska Sort 将数据根据最高 64 位 划分后，如果数据仍然无序或者当前划分数据规模已经较小，使用快速排序 <a target="_blank" rel="noopener" href="https://github.com/orlp/pdqsort">Pattern-defeating quicksort</a>。</li>
</ul>
<h5 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h5><p>DuckDB 使用<strong>大小固定的排序键</strong>。在最新的版本中，作者使用如下结构体<code>struct</code>来保存整合后的键值（<strong>Normalized Key</strong>： 即将多个关键字压缩成128位01串， 比较时可以利用<code>memcpy</code>。 如果128位不够，额外保存数据指针 <code>payload</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FixedSortKeyNoPayload</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> part0;</span><br><span class="line">    <span class="type">uint64_t</span> part1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FixedSortKeyPayload</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> part0;</span><br><span class="line">    <span class="type">uint64_t</span> part1;</span><br><span class="line">    <span class="type">data_ptr_t</span> payload;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在之前的版本中，每个有序块单独存放在一个页 (page) 中。现在作者希望使用<strong>更大的有序块</strong>，于是通过实现 <code>std::iterator</code> ，允许有序块 (sorted run) <strong>使用非连续内存</strong>（多个 pages， 如下图所示）。因为键值大小恒定，每个页存储的键数量也相同，因此可以用整除和模运算计算出某条键存储在哪一页哪一行（作者使用了<a target="_blank" rel="noopener" href="https://github.com/lemire/fastmod">fastmod</a>)。</p>
<img src="/2025/11/04/duckdb_sorting/block_iterator.svg" class="" title="block iterator 示意图">


<p>通过<code>std::iterator</code>，可以把多个页的数据看做一个连续数组（支持随机访问），这使得排序的时候可以直接调用 C++ 库自带的排序算法。</p>
<h4 id="合并有序块"><a href="#合并有序块" class="headerlink" title="合并有序块"></a>合并有序块</h4><h5 id="之前版本的2路归并-cascade-2-way-merge-sort"><a href="#之前版本的2路归并-cascade-2-way-merge-sort" class="headerlink" title="之前版本的2路归并 (cascade 2-way merge sort)"></a>之前版本的2路归并 (<a target="_blank" rel="noopener" href="https://duckdb.org/2021/08/27/external-sorting.html">cascade 2-way merge sort</a>)</h5><p>动机： 当有序块的个数较多的时候，多个线程可以并行进行合并；但是当有序块个数少于线程数的时候，为了提升效率，必须让多个线程一起参与两个有序块的合并。<strong>问题在于如何将两个有序块合并的任务划分成可并行子任务</strong>。为此作者复现了论文 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1406.2628.pdf">Merge Path</a>。</p>
<p>算法的思想如下图所示。考虑合并两个有序数组A和B, 橙色的折线反映了合并的过程：横线表示元素来自B数组，竖线表示元素来自A数组。可以根据线程数量将橙色折线分成若干均匀段，每一段对应一个独立的合并任务。橙色折线的拐点可以用二分搜索计算出来。</p>
<img src="/2025/11/04/duckdb_sorting/merge_path.png" class="" title="merge path 示意图">


<h5 id="新版本的k路归并"><a href="#新版本的k路归并" class="headerlink" title="新版本的k路归并"></a>新版本的k路归并</h5><p>新版本将之前的多线程2路归并推广到k路 （之前产生更长的 sorted runs 对k路归并更友好）。如下图所示，假设我们需要合并$k$个有序块，并将合并后结果的前$\ell$个数存放到 Output Chunk 1 中。我们同样可以用二分搜索找出每个有序块的前面多少个元素属于合并结果的前$\ell$个（对应图中的每个 Sorted Run 里的横线）。这一部分（横线上方的元素）可以分给同一个线程来合并。 </p>
<p>以此类推，可以继续计算合并结果的的下$\ell$个数 （对应下一个 Output Chunk 2），分别对应每个块的哪一段，交给另一个线程来合并。通过这样的划分方法，我们可以把合并$k$个有序块的任务多线程并行化。</p>
<img src="/2025/11/04/duckdb_sorting/k_way_merge.svg" class="" title="k-way merge 示意图">



<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>测试环境： M1 Max MacBook Pro, 10 线程 64 GB 内存</p>
<p>作者先测试了对单列整数的排序，分别考虑了递增、递减、随机数据以及10m, 100m, 1000m 的数据规模。结果如下：</p>
<table>
<thead>
<tr>
<th align="center">Table</th>
<th align="center">Rows [Millions]</th>
<th align="center">Old [s]</th>
<th align="center">New [s]</th>
<th align="center">Speedup vs. Old [x]</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ascending</td>
<td align="center">10</td>
<td align="center">0.110</td>
<td align="center"><strong>0.033</strong></td>
<td align="center">3.333</td>
</tr>
<tr>
<td align="center">Ascending</td>
<td align="center">100</td>
<td align="center">0.912</td>
<td align="center"><strong>0.181</strong></td>
<td align="center">5.038</td>
</tr>
<tr>
<td align="center">Ascending</td>
<td align="center">1000</td>
<td align="center">15.302</td>
<td align="center"><strong>1.475</strong></td>
<td align="center">10.374</td>
</tr>
<tr>
<td align="center">Descending</td>
<td align="center">10</td>
<td align="center">0.121</td>
<td align="center"><strong>0.034</strong></td>
<td align="center">3.558</td>
</tr>
<tr>
<td align="center">Descending</td>
<td align="center">100</td>
<td align="center">0.908</td>
<td align="center"><strong>0.207</strong></td>
<td align="center">4.386</td>
</tr>
<tr>
<td align="center">Descending</td>
<td align="center">1000</td>
<td align="center">15.789</td>
<td align="center"><strong>1.712</strong></td>
<td align="center">9.222</td>
</tr>
<tr>
<td align="center">Random</td>
<td align="center">10</td>
<td align="center">0.120</td>
<td align="center"><strong>0.094</strong></td>
<td align="center">1.276</td>
</tr>
<tr>
<td align="center">Random</td>
<td align="center">100</td>
<td align="center">1.028</td>
<td align="center"><strong>0.587</strong></td>
<td align="center">1.751</td>
</tr>
<tr>
<td align="center">Random</td>
<td align="center">1000</td>
<td align="center">17.554</td>
<td align="center"><strong>6.493</strong></td>
<td align="center">2.703</td>
</tr>
</tbody></table>
<p>可以看到，新的排序算法实现对于有序数据排序效率快了近10倍，对随机数据快了近2倍。</p>
<p>接下来，作者对一个有15列的宽表按某一列进行排序，分别取 6m, 60m, 600m 行。<strong>当数据规模达到 600m 的时候，数据无法完全存储于内存</strong>。可以发现，无论数据能否完全存在内存，新的算法实现性能都优于老版本。尤其是当内存无法容纳所有数据时，排序速度是原来的3倍。</p>
<table>
<thead>
<tr>
<th align="center">Table</th>
<th align="center">SF</th>
<th align="center">Old [s]</th>
<th align="center">New [s]</th>
<th align="center">Speedup vs. Old [x]</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TPC-H SF 1 lineitem by l_shipdate</td>
<td align="center">1</td>
<td align="center">0.328</td>
<td align="center"><strong>0.189</strong></td>
<td align="center">1.735</td>
</tr>
<tr>
<td align="center">TPC-H SF 10 lineitem by l_shipdate</td>
<td align="center">10</td>
<td align="center">3.353</td>
<td align="center"><strong>1.520</strong></td>
<td align="center">2.205</td>
</tr>
<tr>
<td align="center">TPC-H SF 100 lineitem by l_shipdate</td>
<td align="center">100</td>
<td align="center">273.982</td>
<td align="center"><strong>80.919</strong></td>
<td align="center">3.385</td>
</tr>
</tbody></table>
<p>最后，作者测试了新算法的多线程并行情况，如下表所示。可以看到，单线程时旧版本反而快了30%，这是因为两者在实现基数排序的时候的差异。旧版本使用 <strong>out-of-place Least Significant Digit (LSD) radix sort</strong>，速度更快，但占用<strong>更多内存</strong>；新版本使用 <strong>in-place Most Significant Digit radix sort</strong>，原地排序占用<strong>更少内存</strong>。但是当线程数增加到2，二者时间就几乎没有差异。随着线程数继续增加，新版本算法逐渐发挥出优势。</p>
<table>
<thead>
<tr>
<th align="center">Threads</th>
<th align="center">Old [s]</th>
<th align="center">New [s]</th>
<th align="center">Old Speedup vs. 1 Thread [x]</th>
<th align="center">New Speedup vs. 1 Thread [x]</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><strong>3.240</strong></td>
<td align="center">4.234</td>
<td align="center"><strong>1.000</strong></td>
<td align="center"><strong>1.000</strong></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><strong>2.121</strong></td>
<td align="center">2.193</td>
<td align="center">1.527</td>
<td align="center"><strong>1.930</strong></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1.401</td>
<td align="center"><strong>1.216</strong></td>
<td align="center">2.312</td>
<td align="center"><strong>3.481</strong></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">0.920</td>
<td align="center"><strong>0.654</strong></td>
<td align="center">3.521</td>
<td align="center"><strong>6.474</strong></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2020/02/15/combinatorial-optimization-matroid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/15/combinatorial-optimization-matroid/" class="post-title-link" itemprop="url">Combinatorial Optimization-Matroid</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-15 17:41:11" itemprop="dateCreated datePublished" datetime="2020-02-15T17:41:11+00:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>拟阵这个概念在各个场合听了很多遍了，一直没有系统地整理过。本篇基于组合优化经典教材<a target="_blank" rel="noopener" href="https://gitee.com/zhenweiliu/papers/raw/master/papers%20in%20blog/combinatorial_book.pdf">Combinatorial Optimization-Algorithms and Complexity</a>第12章, 主要介绍拟阵的一些基本性质和两拟阵交算法。</p>
<h3 id="独立集系统和拟阵"><a href="#独立集系统和拟阵" class="headerlink" title="独立集系统和拟阵"></a>独立集系统和拟阵</h3><p>定义独立集系统$S&#x3D;(E, \mathcal{I})$, $E$是基本元素的集合, $\mathcal{I} \subseteq 2^{E}$, $\mathcal{I}$中的元素称为独立集。<br>$\mathcal{I}$需要满足遗传性: 如果$A \in \mathcal{I}, B \subseteq A$, 那么$B \in \mathcal{I}$.</p>
<p>举例:<br>定义在无向图$G(V, E)$上的独立集系统, $\mathcal{I}$是不构成环的边集合, 显然满足遗传性。<br>求无向图的最大生成树, 实际上是先给$E$中每个元素赋予一个权值(边权), 然后求一个权值最大的独立集。<br>回忆一下kruskal算法, 每次选一条边权最大的边, 如果把它加入答案不形成环，就把它加入答案。<br>推广一下，给定任意独立系统，任意给每个元素一个非负的权值，要求权值最大的独立集，容易得到下面的贪心算法:</p>
<ol>
<li>将元素按权值从大到小排序.</li>
<li>按顺序依次考虑每个元素, 如果把这个元素加入答案后仍然是一个独立集，就加入答案。</li>
</ol>
<p>不幸的是, 这个算法只有在特定条件下才会给出最优解。<br>比如考虑求二分图图的最大权值匹配, 定义独立集为可以形成匹配的边集。考虑一个4个点3条边的图$V&#x3D;{u_1, u_2, u_3, u_4}, w(u_1,u_2)&#x3D;w(u_3, u_4)&#x3D;5, w(u_1, u_4)&#x3D;8, w(u_2, u_3) &#x3D; 1$, 贪心算法会选择边$(u_1, u_4), (u_2, u_3)$, 权值是9, 最优解是$(u_1, u_2), (u_3,u_4)$, 权值是10.<br>我们把贪心算法能够使用的独立集系统称为<strong>拟阵(matroid)</strong>, 比如上面定义在无向图边集上的独立集系统(一个边集是独立集当且仅当不包含环)，贪心算法实际上就是kruskal算法, 为了方便, 给它一个名字叫<strong>图拟阵(graphic matroid)</strong>。<br>特别地, 很多问题只要求取一个最大的独立集, 即元素权重都是单位1的特殊情况, 如果这个独立集系统是拟阵, 我们称这种拟阵叫做<strong>unweighted matroid</strong>.</p>
<h3 id="拟阵的性质"><a href="#拟阵的性质" class="headerlink" title="拟阵的性质"></a>拟阵的性质</h3><p>那么如何判定一个独立集系统$M$是不是拟阵呢？下面三条定义是等价的:</p>
<ol>
<li>$M$是拟阵, 任意给元素分配非负的权值, 贪心算法能得到最优解。</li>
<li>假设有2个独立集$I_1, I_2, |I_2| &#x3D; |I_1|+1$, 那么$\exists e \in I_1\backslash I_2, I_1 \cup e \in \mathcal{I}$. 通俗地讲，就是如果2个独立集大小相差1, 那么一定可以从大的独立集那里拿一个给小的, 使新的集合还是独立集。</li>
<li>若$A \subseteq E$, $I_1, I_2 \subseteq A$是$A$上的极大独立集, 那么$|I_1|&#x3D;|I_2|$. 也就是$E$的任意子集上的极大独立集大小相同。</li>
</ol>
<p>证明:<br>$1 \rightarrow 2:$<br>设$|I_1|&#x3D;k, |I_2| &#x3D; k+1$, 只要令<br>$$<br>w(e) &#x3D; \begin{cases}<br>    k+2 &amp; e \in I_1 \<br>    k+1 &amp; e \in I_1 \backslash I_2 \<br>    0  &amp; e \notin I_1 \cup I_2<br>\end{cases}<br>$$<br>假设$\forall e \in I_1\backslash I_2, I_1 \cup e \notin \mathcal{I}$, 按照贪心算法会选择$I_1$, 权值是$k(k+2)$, 实际上$I_2$的权值是$(k+1)(k+1)$更大，贪心算法就挂了。</p>
<p>$2 \rightarrow 3:$<br>显然, 如果$|I_1| \lt |I_2|$, 考虑$I_3 \subseteq I_2, |I_3|&#x3D;|I_1|+1$, 根据(2)可以从$I_3$那里拿一个元素给$I_1$构成一个更大的独立集, 与$I_1$是极大的矛盾。</p>
<p>$3 \rightarrow 1:$<br>假设$w(e_1) \geq w(e_2) \geq w(e_3) \geq \cdots$, 贪心算法求出的权值最大独立集是$I&#x3D;{e_{i_1}, e_{i_2}, \cdots, e_{i_m} }$, 最优解是$J&#x3D;{e_{j_1}, e_{j_2}, \cdots, e_{j_m} }$.<br>设$k$是最小的正整数满足$i_k \gt j_k$. (让$I$和$J$的元素一一对应, 前面$k-1$个都是$I$中编号小, 第$k$个是$J$中编号小, 因为$J$的权值比$I$大, $k$一定存在). 利用(3), 令$A:&#x3D;{e_1, e_2, \cdots, e_{j_k}}$, 根据贪心算法的过程 $I \cap A$是 $A$上的极大独立集, 大小为$k-1$, 而$J \cap A$也是$A$上的独立集, 甚至还不是极大的，大小却是$k$. 违反了(3). </p>
<p>另外(2)还可以推出只要两个独立集大小不一样, 就可以从大集合里拿一个给小的, 新集合还是独立集。</p>
<p>接下来引入几个概念:</p>
<ol>
<li>秩(Rank). 根据上面第3条, $E$的任意子集$A$上的极大独立集大小相等。这个大小就是$A$的秩, 记为$r(A)$.</li>
<li>基(Basis). $A$的基上的任意极大独立集称为$A$的基.</li>
<li>回路(Circuit). 极小的非独立集(相关集), 即它本身不是独立集，但删掉任意一个元素后都是独立集。</li>
</ol>
<p>为了方便理解, 我们以图拟阵为例子.<br>图拟阵中任意边集$A \subseteq E$, $r(A)$是其生成子图的生成森林边数(也就是生成子图的顶点数-联通块个数), 基就是任意生成森林, 回路就是一个简单环。</p>
<p>再看一个独立集系统, 它的元素集合是一些维数相同的向量, 独立集的定义就是线性无关的向量集合。根据线性代数的知识, 任意向量集合的极大线性无关组大小相同，即满足上面的判断独立集是否是拟阵的第3条，所以该独立集系统是一个拟阵，之后我们称它为<strong>线性拟阵</strong>。<br>线性拟阵的秩, 基都和线性代数中吻合, 回路就是极小的线性相关组。<br>参加过算法竞赛的同学可以去拿BZOJ2460练练手, 就是求一个定义域在$F_2^n$下的线性拟阵权值最大的独立集, 用贪心算法解决即可。</p>
<p>下面是关于回路的一个有用的定理:<br><strong>定理1</strong>:<br>如果往独立集$I$中加入一个元素$e$后, $I+e$不独立了, 那么$I+e$中包含唯一的一个回路。并且这个回路就是${c \mid I+e-c \in \mathcal{I}}$</p>
<p>可以拿图拟阵来理解这个定理: 考虑不成环的一些边(独立), 往里面加了一条, 如果成环(不独立), 那么会有唯一的一个简单环(回路), 这个回路就是新的边集($I+e$)里面那些去掉后会使得图没有环的边。</p>
<p>我们首先证明$C&#x3D;{c \mid I+e-c \in \mathcal{I}}$确实是$I+e$中的回路。</p>
<ul>
<li>显然$C \subseteq I+e$, 先证明$C$不是独立集。 假设$C$是独立集, 那么一定可以往$C$里面加元素将它扩充成$I+e$的一个基$C’$. 因为$r(I+e) &#x3D; r(I) &#x3D; |I|$, 因此$|C’|&#x3D;|I|$, 所以$C’ &#x3D; I+e-c, c \notin C’$, 而根据$C$的定义, $c \in C$, 导致矛盾。   </li>
<li>再证明$C$去掉任意一个元素后都是独立集. $\forall c \in C, I+e-c \in \mathcal{I}$,而$ C-e \subseteq I+e-c$, 根据遗传性$C-e \in \mathcal{I}$.</li>
</ul>
<p>唯一性证明:<br>假设还有另一个回路$D$. 考虑$c \in C \backslash D$, 容易发现$ D \subseteq I+e-c$, 根据$C$的定义, $I+e-c \in \mathcal{I}$, 从而根据遗传性推出$D$是独立集,导致矛盾。</p>
<p>下面的内容和书上不完全一致, 因为我自己看书的时候在这些地方卡了好几天, 所以我尝试用自己的方法来解释, 因此可能会有一些错误, 希望发现的兄弟指出来。</p>
<p>为了之后方便解释拟阵交的算法，还需要引入一个span的概念。<br>考虑$A \subseteq E, S(A):&#x3D;{B \mid A \subseteq B, r(A)&#x3D;r(B)}$.<br>先来验证$S(A)$关于集合的并操作封闭, 即$\forall B_1,B_2 \in S(A), B_1 \cup B_2 \in S(A)$.<br>证明:<br>设$\mathcal{B}$是$A$的基, 那么显然它也是$ B_1,  B_2$的基。 我们证明它还是$ B_1 \cup B_2$的基: 如果它不是，那么它是非极大的独立集, 那么可以往里面加一个元素使它还是独立集, 但是它已经是$ B_1,  B_2$的基了，所以又不可能往它里面加$B_1$或者$B_2$的元素, 导致矛盾。</p>
<p>定义$span(A):&#x3D;\bigcup\limits_{B_i \in S(A)} B_i$, 显然$span(A) \in S(A)$, 等价地, $span(A)$就是极大的(也是最大的)$A$的超集, 满足秩和$A$的秩一样。</p>
<p><strong>引理1</strong>: $\forall B \in S(A), span(B) &#x3D; span(A)$.<br>证明:<br>$B \in S(A) \rightarrow B \subseteq span(A) \rightarrow span(A) \in S(B) \rightarrow span(A) \subseteq span(B)$<br>$A \subseteq span(A) \subseteq span(B) \rightarrow span(B) \in S(A) \rightarrow span(B) \subseteq span(A)$.<br>所以$span(A)&#x3D;span(B)$.<br>根据上面的引理, 容易验证$span(span(A)) &#x3D; span(A)$.</p>
<p>在图拟阵中, 如果$A$是某个边集, $span(A)$ 就是往$A$中加入尽可能多的边, 使得生成子图的顶点数不会增多。</p>
<p>下面的定理更加简洁的表示出了$span(A)$.<br><strong>定理2</strong>: $span(A) &#x3D; {e \mid r(A+e)&#x3D;r(A)}$<br>证明:</p>
<ul>
<li>记$K&#x3D;{e \mid r(A+e)&#x3D;r(A)}$, 那么$K$可以写作<br>$$<br>\bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (A+e)<br>$$<br>而$\forall e \in E \backslash A, r(A+e)&#x3D;r(A)$, 有$A+e \in S(A)$, 故$K \in S(A), K \subseteq span(A)$.</li>
<li>反过来, 考虑$e \in span(A) \backslash A$, 显然$r(A+e) &#x3D; r(A)$. 因此$span(A)$可以写成<br>$$<br>\bigcup\limits_{e \in span(A) \backslash A: r(A+e)&#x3D;r(A)} (A+e)<br>$$<br>容易看到$span(A) \subseteq K$.</li>
</ul>
<p>下面为拟阵交做铺垫的两个引理:</p>
<p><strong>引理2</strong>: $span(A) &#x3D; A \cup {C \mid \text{C is circuit with all but one element in } A }$<br>证明:</p>
<ul>
<li>首先证明$span(A)$可以表示成$A$和若干特殊回路的并, 特殊回路指的是只有一个元素不在$A$内的回路。根据上面的定理<br>$$<br>\begin{aligned}<br> span(A) &amp;&#x3D; \bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (A+e) \\<br> &amp;&#x3D; A \cup \bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (A+e)  \\<br> &amp;&#x3D; A \cup \bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (\text{Basis of } A +e) \\<br> &amp;&#x3D; A \cup \bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (\text{Circuit consists of basis of } A \text{ and } e)<br>\end{aligned}<br>$$</li>
<li>再证明任意特殊回路$\subseteq span(A)$. 给定某个特殊回路, 我们把它表示成$I+e, I \in \mathcal{I}$, 我们只要证明$r(A+e)&#x3D;r(A)$. 假设$r(A+e) \gt r(A)$, 那么存在一个$A$的基$B, B+e \in \mathcal{I}$. 考虑$I$, 如果它不是$A$的基, 那么可以先把它扩充成$A$的基, 记作$I’$. 比较$I’$和$B+e$, 后者大小比前者大1, 因此可以从后者拿一个元素给前者, 但是这个元素不可能来自$B$, 否则$I’$就不是集了。所以这个元素只能是$e$, 因此$I’+e \in \mathcal{I}$, 而它的子集$I+e$却是一个回路, 导致矛盾。</li>
</ul>
<p><strong>引理3</strong>: 若$I \in \mathcal{I}, I+e \notin \mathcal{I}$, $C$是$I+e$中唯一的circuit, 则$\forall c \in C, span(I) &#x3D; span(I+e-c)$, 且$I+e-c \in \mathcal{I}$.<br>证明:</p>
<ul>
<li>$r(I+e)&#x3D;r(I) \rightarrow I+e \in S(I)$, 根据引理1, $span(I) &#x3D; span(I+e)$.</li>
<li>根据定理1, $I+e-c \in I$, $r(I+e-c) &#x3D;r(I+e) &#x3D;|I|$, 又因为$I+e-c \subseteq I+e$, 所以$I+e \in S(I+e-c)$, 从而有$span(I+e-c) &#x3D; span(I+e)$.</li>
<li>综上$span(I+e-c) &#x3D; span(I)$.</li>
</ul>
<h3 id="拟阵的交"><a href="#拟阵的交" class="headerlink" title="拟阵的交"></a>拟阵的交</h3><p>许多时候, 一个组合优化问题并不能表示成一个拟阵, 但是却可以表示成两个拟阵甚至更多拟阵的交。比如二分图匹配, 在最开始我们已经举了一个反例说明它虽然是个独立集系统，但并不是一个拟阵。然而，我们可以把它表示成两个拟阵的交:<br>我们用$G(L, R, E)$表示一个二分图, $L, R$分别是两边的顶点集合, $E$是边集, 也是拟阵的基本元素集合。<br>定义拟阵$M_1(E, \mathcal{I}_1)$: 边集$A \in \mathcal{I}_1$ 当且仅当$A$中边的左端点互不相同。<br>定义拟阵$M_2(E, \mathcal{I}_2)$: 边集$A \in \mathcal{I}_2$ 当且仅当$A$中边的右端点互不相同。<br>容易验证$A$是合法的匹配当且仅当$A \in \mathcal{I}_1 \cap \mathcal{I}_2$.</p>
<p>一般地, 独立集系统$S(E, \mathcal{I})$表示成$K$个拟阵的交, 记作$<br>S &#x3D; \bigcap_{i&#x3D;1}^K M_i(E, \mathcal{I}<em>i), \mathcal{I} &#x3D; \bigcap</em>{i&#x3D;1}^K \mathcal{I}_i $.</p>
<p>如果一个独立集能表示成$K$个拟阵的交的形式, 能给我们带来什么方便之处呢?</p>
<p><strong>定理3</strong>: 任意两个极大独立集$A, B$, 不妨设$|A| \leq |B|$, 一定满足$|B| \leq K|A|$.<br>从近似算法的角度, 如果只需要求最大独立集(unweighted matroid), 随便取一个极大独立集就可以做到$K$的近似比, 比如上面的不带权的二分图匹配问题, 随便取一个极大匹配, 它大小就至少是最优解的一半。</p>
<p>证明: </p>
<ul>
<li>设$A_i$是第$i$个拟阵中$A\cup B$包含$A$的极大独立集。用反证法容易证明$\forall e \in B\backslash A, e \notin \bigcap A_i \backslash A$, (如果属于, 那么$A+e$也是独立集), 也就是说, $e$最多出现在$K-1$个$Ai \backslash A$里。因为$A_i \backslash A$里面的元素只能在$B\backslash A$里, 进一步可以推出$\sum\limits_{i&#x3D;1}^{K} |A_i \backslash A| \leq (K-1)|B\backslash A| \leq (K-1)|B|$. </li>
<li>同样地, 定义$B_i$是第$i$个拟阵中$A\cup B$包含$B$的极大独立集, 根据拟阵的性质$|A_i| &#x3D; |B_i|$.</li>
<li>$$<br>  \begin{aligned}<br>  K|B| &amp;\leq \sum\limits_{i&#x3D;1}^K{|B_i|} \\<br>  &amp;&#x3D; \sum\limits_{i&#x3D;1}^K{|A_i|} \\<br>  &amp;&#x3D; \sum\limits_{i&#x3D;1}^K{(|A|+|A_i \backslash A|)} \\<br>  &amp;&#x3D; K|A| + \sum\limits_{i&#x3D;1}^K{|A_i \backslash A|} \\<br>  &amp;\leq K|A| + (K-1)|B|<br> \end{aligned}<br> $$<br> 从而推出$B \leq K|A|$.</li>
</ul>
<p>下面的定理挺有趣, 但似乎没什么卵用。<br><strong>定理4</strong>: 任意一个独立集系统$S(E, \mathcal{I})$都可以表示成有限个拟阵的交。<br>证明: </p>
<ul>
<li>设独立集系统包含$K$个极小非独立集$C_1, C_2 \cdots C_K$.</li>
<li>构造$K$个拟阵$M_i(E, \mathcal{I}_i)$, 其中$ \mathcal{I}_i &#x3D; { A \subseteq E \mid C_i \not \subseteq A}$, 用判定你真的第二条规则可以证明$M_i$是拟阵。</li>
<li>我们证明$S$可以表示成它们的交, 即$ \forall A \in \mathcal{I}$当且仅当$\forall i, A \in \mathcal{I}$, 这个根据$M_i$的定义很容易证明。</li>
</ul>
<p>上面这个整理看起来很厉害，但对大多数实际问题并没有很大的帮助, 因为由上面的方法构造出来的独立集往往是很多个拟阵的交。<br>ps: 上面两个定理来自张国川老师在zju开的课程&lt;&lt;应用运筹学基础&gt;&gt;。</p>
<p>下面的定理说明表示成三个或者超过三个拟阵的交对解决问题并没有很大的帮助。<br><strong>定理5</strong>: 如果把一个独立集系统表示成3个unweighted matroid的交, 求它的最大独立集是<strong>NP-Hard</strong>的。<br>证明:</p>
<ul>
<li>哈密顿路径问题可以规约到3拟阵交。哈密顿路径问题指的是给定有向图$G(V,E)$, 起点$s$和终点$t$, 求一条$s$到$t$的路, 且经过图中所有点一次。</li>
<li>定义$M_1$是定义在将图$G$的边去掉方向后的无向图$G’$上的图拟阵。</li>
<li>定义$M_2$是定义在图$G$上边集的拟阵, 独立的定义是每个点的出度不超过1, $t$的出度是0. (利用第三条规则证明是拟阵)</li>
<li>定义$M_3$是定义在图$G$上边集的拟阵, 独立的定义是每个点的入度不超过1, $s$的入度是0.</li>
<li>容易验证上面3个拟阵的交的独立集是若干条不相交路径的并, 且其中一条路径是从$s$到$t$. 原图存在哈密尔顿路径当且仅当最大独立集的规模是$|V|-1$.</li>
</ul>
<h3 id="Intersection-of-2-unweighted-matroids"><a href="#Intersection-of-2-unweighted-matroids" class="headerlink" title="Intersection of 2 unweighted matroids"></a>Intersection of 2 unweighted matroids</h3><p>2个拟阵的交是多项式可解的, 这里介绍一下算法(有点难理解, 需要多花点时间)。我花了很多时间去揣摩算法一步步推导的motivation, 个人觉得学习算法不但要理解算法的过程和正确性，更要学习作者是如何一步步想到这个算法的。因此我希望把下面的过程写成诱导性质的，而不是<br>直接给出一个算法，然后证明它的正确性和复杂度。</p>
<p>我们先回忆一下不带权二分图最大匹配的过程:<br>假设当前已经求得匹配$I$, 定义相对于$I$的增广路为长度为奇数的边的序列$L&#x3D;[e_1, e_2 \cdots e_{2n-1}]$, 其中$e_{2k-1} \notin I, e_{2k} \in I$, 容易验证$I \oplus S$也是一个匹配, 且大小相比$M$增加了1. 增广路定理表明如果当前匹配是$I$, 且不存在相对于$I$的增广路，那么它就是最大匹配。</p>
<p>我们从拟阵的角度来看这个过程:<br>假设我们每次是从左边($M$)的点出发找增广路.<br>$I \oplus S &#x3D; I + e_1 - e_2 + e_3 \cdots -e_{2n-2} + e_{2n-1}$.<br>$I+e_1$在保持左边独立性的前提下让独立集大小增加$1$ ($I+ e_1 \in \mathcal{I}_1$), 但多了一条边之后, 右边的某个点就会和2条边相关, 右边的独立性被破坏 ($I + e_1 \notin \mathcal{I}<em>2$).<br>$I+e_1-e_2$这一步去掉$e_2$, 又让右边满足独立($I+e_1-e_2 \in \mathcal{I}<em>2$), 而且是去掉一个元素, 左边肯定还是独立。<br>…<br>$I + e_1 - e_2 + e_3 \cdots -e</em>{2n-2} + e</em>{2n-1}$这一步在保持左边独立性的前提下让独立集大小增加1, 而且幸运的是, 右边也是独立的, 于是就找到了一条增广路。<br>这个过程本质上是在奇数步尝试增加一个元素, 并且保持$M_1$中的独立性，然而这可能会导致$M_2$中的独立性被破坏, 所以在偶数步又去掉一个元素, 使得重新满足$M_2$中的独立性, 直到在某个奇数步运气特别好, 没有破坏右边的独立性。拟阵交算法就是从中受到启发得出的。</p>
<p>上面的过程看起来似乎挺简单的？但是有一个问题，用上面的方法找增广路, 在第$i$步找一个元素$e_i$, 它符不符合要求是和$e_1, e_2 \cdots e_{i-1}$的选择有关的, 这样搜索空间就相当大了, 难以用多项式bound住, 所以我们需要把增广路的条件放宽一点, 后面会证明放宽条件之后找到的解也一定是最优解。</p>
<p>后面的内容主要是基于<a target="_blank" rel="noopener" href="https://gitee.com/zhenweiliu/papers/raw/master/papers%20in%20blog/lec11.pdf">MIT matroid lecture</a>, 因为我个人觉得书上讲得过于突兀, 有点摸不着头脑, 我看了3-4遍才看明白。相比之下MIT的这份课件要易于理解一些。当然, 能将两者结合起来看，可以更好地理解算法提出的motivation。</p>
<p>假设当前的独立集是$I \in \mathcal{I}_1 \cap \mathcal{I}_2$, 如何放宽条件呢？</p>
<ul>
<li>考虑奇数步(第$2k+1$步), 原本我们是要求$I+e_1-e_2 \cdots -e_{2k} + e_{2k+1} \in \mathcal{I}<em>1$, 但是这个条件太难了, 我们放宽成 $I-e</em>{2k}+e_{2k+1} \in \mathcal{I}_1$.</li>
<li>同理偶数步放宽成$I - e_{2k} + e_{2k-1} \in \mathcal{I}_2$.</li>
</ul>
<p>定义:</p>
<ul>
<li>$X_1 :&#x3D; {e \mid e \notin I, I+e \in \mathcal{I}_1 }$.</li>
<li>$X_2 :&#x3D; {e \mid e \notin I, I+e \in \mathcal{I}_2 }$.</li>
<li>辅助图$G$(有向图, 而且是二分图), 点是独立集基本元素, 两个点$e_x \in E \backslash I$, $e_y \in I$:<ul>
<li>如果$I-e_y+e_x \in \mathcal{I}_2$, 那么$e_x$向$e_y$连边。</li>
<li>如果$I-e_y+e_x \in \mathcal{I}_1$, 那么$e_y$向$e_x$连边。</li>
</ul>
</li>
</ul>
<p>容易验证放宽条件后的增广路(为了方便, 把它叫做”广义增广路”好了)就是辅助图中从$X_1$出发到$X_2$的一条简单路径。<br>看下面图中的例子, (a)是定义在有向图边集上的一个独立集系统, 将它表示成2个拟阵的交, $M_1$是图拟阵(独立条件是不考虑边的方向无环), $M_2$独立集的条件是每个点最多有一条入边, 当前已经选择的独立集$I&#x3D;{e_2, e_4, e_6}$, 即圈起来的边, 图(b)是相应的辅助图:</p>
<img src="/2020/02/15/combinatorial-optimization-matroid/1.png" class="">
<p>一条广义增广路对应$e_1$到$e_5$的一条简单路。观察发现, $L_1&#x3D;[e_1, e_2, e_3, e_4, e_5]$就是一条广义增广路, 但是$I \oplus L_1&#x3D;{e_1, e_3, e_5, e_6}$并不是原问题的独立集(${e_1, e_3, e_6}$构成环)。<br>再看$L_2&#x3D; {e_1, e_4, e_5}$, 观察发现$I \oplus L_2 &#x3D; {e_1, e_2, e_5, e_6} $是独立集。说明广义增广路不一定是增广路, 即$I \oplus L \in \mathcal{I}_1 \cap \mathcal{I}_2$不一定被满足。<br>注意$L_2$的长度要比$L_1$短, 因此我们大胆猜测, 如果我们找的是一条从$X_1$到$X_2$最短路, 那么这条广义增广路是增广路。</p>
<p>因此我们得到下面的算法:</p>
<ol>
<li>初始化$I:&#x3D;\emptyset$.</li>
<li>构造相对于$I$的辅助图$G(I)$.</li>
<li>找到相应的起点终点集合$X_1, X_2$.</li>
<li>用宽度优先搜索(BFS)找到从$X_1$到$X_2$最短路$L$, 令$I:&#x3D; I \oplus L$, 返回第2步。如果从$X_1$到$X_2$没路, 算法结束。</li>
</ol>
<p>幸运的是，这个算法就是对的。下面给出证明, 不关心证明的大哥们可以直接用上面的算法。 </p>
<p>首先来证明最短的广义增广路是增广路, 设最短的广义增广路$L&#x3D;{e_1, e_2 \cdots e_{2k+1}}(k&gt;&#x3D;1)$, $k&#x3D;0$的情况, 说明$e_1 \in X_1 \cap X_2$, 显然合法。<br>因为$L$是最短路, $e_2, e_3,  \cdots e_{2k+1} \notin X_1$, $e_1, e_2, \cdots e_{2k} \notin X_2$, 为了方便, 我们用$L_{i,j}$来表示$[e_i, e_2 \cdots e_j]$. </p>
<ul>
<li>$I \oplus L \in \mathcal{I}_1$:<ul>
<li>我们通过归纳法证明$\forall 0 \leq i \leq k, span_1(I+e_1) &#x3D; span_1(I\oplus L_{1, 2i+1})$, $span_i$表示第$i$个拟阵的span, 显然这个结论比$I+e_1-e_2 \cdots +e_{2i+1}\in \mathcal{I}_1$更强。   </li>
<li>$i &#x3D; 0$显然成立。</li>
<li>考虑$i \geq 1$, 因为$I \in \mathcal{I}<em>1, I+e</em>{2i+1} \notin \mathcal{I_1}(否则e_{2i+1}\in X_1)$, 那么$I+e_{2i+1}$包含唯一circult $C$, 且$e_{2i} \in C$。</li>
<li>假设$span_1(I+e_1) &#x3D; span_1(I\oplus L_{1,2i-1})$, 那么$I\oplus L_{1,2i-1} \in \mathcal{I}<em>1$。如果${e_2, e_4, \cdots e</em>{2i-2} }$中的某一个$e_j \in C$, 那么$I-e_j+e_{2i+1} \in \mathcal{I}<em>1$, 根据辅助图的定义$e_j$到$e</em>{2i+1}$有边, 那么$[e_1, e_2 \cdots e_{2i+1}]$就不是最短路了, 因为$[e_1, e_2, \cdots e_j, e_{2i+1}]$更短。</li>
<li>$I \oplus L_{1,2i-1} + e_{2i+1}$可以看做$I+e_{2i+1}$删去$e_2, e_4 \cdots e_{2i-2}$再加上$e_1, e_3, \cdots e_{2i-1}$, 上一条说明没有删掉$C$中的边, 因此$C \subseteq I \oplus L_{1,2i-1} + e_{2i+1} $。</li>
<li>$I \oplus L_{1,2i-1} \in \mathcal{I}<em>1$, 但是$I \oplus L</em>{1,2i-1} + e_{2i+1} $, 因此$I \oplus L_{1,2i-1} + e_{2i+1} $包含唯一circult, 并且就是$C$. </li>
<li>$e_{2i} \in C$, 所以根据引理3,<br>   $span_1(I \oplus L_{1,2i-1} + e_{2i+1} -e_{2i}) &#x3D; span_1(I \oplus L_{1,2i-1}) &#x3D; span_1(I+e_1)$.</li>
</ul>
</li>
<li>$I \oplus L \in \mathcal{I}_2$:<ul>
<li>同样使用归纳法证明, 只不过方向需要反一下, $\forall 0 \leq i \leq k, span_2(I) &#x3D; span_2(I\oplus L_{2i+1, 2k+1})$.</li>
<li>所有的证明和上面都是对称的(从$i&#x3D;k$开始, 推到$i&#x3D;0$)。</li>
</ul>
</li>
</ul>
<p>最后还剩下一件事, 我们得证明如果不存在从$X_1$到$X_2$的广义增广路, 那么当前独立集$I$就是最大的。</p>
<p><strong>定理6(Min-Max Formula)</strong>:<br>$$<br>\max_{I \in \mathcal{I}}|I| &#x3D; \min_{U \subseteq E}{r_1(U)+r_2(E \backslash U)}<br>$$<br>首先容易证明$\forall I \in \mathcal{I}, \forall U \subseteq E, |I| \leq r_1(U)+r_2(E \backslash U)$:</p>
<ul>
<li>把$I$分成$A&#x3D;I \cap U和B&#x3D; I \backslash A$两部分。</li>
<li>$A \subseteq U, A \in \mathcal{I}_1 \rightarrow r_1(U) \geq |A|$.</li>
<li>$B \subseteq E \backslash U, B \in \mathcal{I}_2 \rightarrow r_2(E \backslash U) \geq |B|$.</li>
</ul>
<p>考虑算法的最后一次迭代, 也就是发现$X_1$到$X_2$没有路的时候, 所求出的独立集是$I$.<br>如果$X_1$或者$X_2$是空集, 那么$I$是$M_1$或者$M_2$的极大独立集, 显然$I$就是最大独立集。之后默认$X_1,X_2 \neq \emptyset$。<br>令$U$为辅助图中能到达$X_2$的元素的集合, 我们证明$|I| &#x3D; r_1(U) + r_2(E \backslash U)$, 即上面的定理的等号成立。</p>
<ul>
<li>$X_2 \subseteq U, X_1 \cap U &#x3D; \emptyset$, 否则算法会继续迭代。</li>
<li>证明$r_1(U)&#x3D;|I\cap U|$:<ul>
<li>假设$ r_1(U) \neq |I\cap U|$, 那么$r_1(U) \gt |I \cap U|$, 进而$\exists x\in U \backslash I, (I \cap U) + x \in \mathcal{I}_1$.</li>
<li>如果$I \subseteq U$,即$I \cap U &#x3D; I$, 那么$I+x \in \mathcal{I}_1$, 说明$e \in X_1$, 而$X_1 \cap U &#x3D; \emptyset$, 所以这种情况不可能发生, 也就是说$I \backslash U \neq \emptyset$.</li>
<li>因为$I \cap U + x \in \mathcal{I}_1$, 所以$I+e$要么$\in \mathcal{I}_1$, 要么包含唯一的circuit, 不管哪种情况, 都$\exists y \in I \backslash U, I+x-y \in \mathcal{I}_1$, 从而根据辅助图的定义$y$到$x$有边, 根据$U$的定义$x \in U$可以推出$y \in U$, 导致矛盾。</li>
</ul>
</li>
<li>同理可以证明$r_2(E \backslash U) &#x3D; |I \cap (E \backslash U)|$, 和前面部分是对称的。</li>
<li>综上$|I| &#x3D; r_1(U) + r_2(E \backslash U)$。</li>
</ul>
<h3 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h3><p><a target="_blank" rel="noopener" href="https://www.codechef.com/OCT19A/problems/CNNCT2">codechef monthly challenge的一个题目</a>。<br>题目大意是给出两个$n$个点$m$条边的无向图$G_1(V_1, E_1), G_2(V_2, E_2)$, 求一个最小的下标集合$J$, 使得$G_1(V_1, E_1(J))$和$G_2(V_2, E_2(J))$ 都是联通的。</p>
<p>这个题需要转化一下, 只需要求出定义在$G_1$和$G_2$上的图拟阵的交的最大独立集$|I|$,容易验证 $|J| &#x3D; 2n-2-|I| $。</p>
<p>求两个图拟阵的交的细节:<br>构造辅助图：</p>
<ul>
<li>$X_1, X_2$就是加入后仍然不构成环的那些边。只需要预处理每个点属于哪个联通块(DFS&#x2F;并查集)。</li>
<li>如果$I-e_y+e_x \in \mathcal{I}_2$, 那么$e_x$向$e_y$连边。实际上只需要考虑加入第$i$条边后, 如果在$G_2$中构成环, 那么环上的每条边 对应的点在辅助图中 向第$i$条边对应的点 连边。</li>
<li>如果$I-e_y+e_x \in \mathcal{I}_1$, 那么$e_y$向$e_x$连边。实际上只需要考虑加入第$i$条边后, 如果在$G_1$中构成环, 那么环上的每条边 对应的点在辅助图中 向第$i$条边对应的点 连边。</li>
<li>如何遍历一个环: 我的做法是将森林预处理成有根树的集合, 边$(u,v)$加入后如果形成环, 那么让$u, v$沿着父亲边向上走直到他们在最近公共祖先相遇。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.codechef.com/viewsolution/29825505">参考代码</a></p>
<p>还有几个练习题也是拟阵交：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3792">2011-2012 ACM&#x2F;ICPC, Asia, Dhaka. E. Game of Connect</a></li>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1284/problem/G">Hello 2020. G. Seollal</a></li>
<li><a target="_blank" rel="noopener" href="https://naipc18.kattis.com/problems/rainbowgraph">NAIPC 2018. G. Rainbow Graph</a></li>
<li><a target="_blank" rel="noopener" href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051707/0000000000158f1c">Google Code Jam 2019. Round 3. Datacenter Duplex</a></li>
<li><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=6636">2019 Multi-University Training Contest 6. C. Milk Candy</a></li>
<li><a target="_blank" rel="noopener" href="https://contest.yandex.com/contest/7636/problems/F/">Yandex Algorithm 2018. Round 1. F. Yet Another Binary Matrix</a></li>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/gym/102156/problem/D">2019 Petrozavodsk Winter Camp Yandex Cup. D. Pick Your Own Nim</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2020/01/01/Binpacking-First-Fit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/Binpacking-First-Fit/" class="post-title-link" itemprop="url">Binpacking-First Fit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-01 16:59:41" itemprop="dateCreated datePublished" datetime="2020-01-01T16:59:41+00:00">2020-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有关Binpacking问题的定义和其他近似算法见我<a target="_blank" rel="noopener" href="http://zhenweiliu.gitee.io/blog/2019/07/28/Approximation-Algorithm-3-The%20Binpacking%20Problem/">之前的文章</a>, 本篇主要补充Binpacking问题First Fit算法可以做到1.7的渐进近似比。<br>First Fit算法: 依次考虑每个物品, 逐个检查当前已经开着的箱子, 发现第一个能装下它的箱子就装。如果都装不下，开一个新的箱子装它。</p>
<h4 id="证明框架"><a href="#证明框架" class="headerlink" title="证明框架"></a>证明框架</h4><p>设第$i$个物品的体积是$s_i$.<br>设计一个权函数$w(x)$, $w(S):&#x3D; \sum_{i \in S}{w(s_i)}$.<br>我们用$w(I)$作为桥梁，证明$ALG(I) - \epsilon \leq w(I) \leq 1.7 OPT(I)$, 从而证明1.7的渐进近似比。<br>权函数$w(x)$的定义如下(数学家们凑出来的):<br>$$<br>\begin{aligned}<br>w(x) &amp;&#x3D; \frac{6}{5}x + bonus(x) \\<br>bonus(x) &amp;&#x3D; \begin{cases} 0 &amp; x \le \frac{1}{6} \ \frac{3}{5}(x - \frac{1}{6}) &amp; \frac{1}{6} &lt; x \le \frac{1}{3} \ \frac{1}{10} &amp; \frac{1}{3} &lt; x \le \frac{1}{2} \ \frac{2}{5} &amp; x &gt; \frac{1}{2} \end{cases}<br>\end{aligned}<br>$$<br>注意, $bonus(x)$是单调不减的。<br>第一个不等号的意思是, 算法解除掉少数几个箱子, 剩余的箱子的平均权重至少是1.<br>第二个不等号实际上是由更强的结论 任意一个箱子$B_j$, $w(B_j) \leq 1.7$ 得到的。</p>
<h4 id="Part1-w-B-j-leq-1-7"><a href="#Part1-w-B-j-leq-1-7" class="headerlink" title="Part1: $w(B_j) \leq 1.7$"></a>Part1: $w(B_j) \leq 1.7$</h4><p>只要证明$bonus(B_j) \leq 0.5$.<br>将物品按照bonus函数的4段分成4类。</p>
<ul>
<li>如果箱子里含有第4类($\gt \frac{1}{2}$)的物品, 那么已经有0.4的bonus, 只要证明剩下的不会超过0.1.<ul>
<li>如果含有第3类, 那么再也装不下第1类和第2类。 这时候bonus刚好是0.5.</li>
<li>如果不含第3类, 最多装2个第2类。显然只装1个第2类最多凑到0.1. 如果装2个第2类, 设体积分别是$x, y$. $\frac{3}{5}(x-\frac{1}{6}) + \frac{3}{5}(y-\frac{1}{6}) &#x3D; 0.6(x+y)-0.2 \lt 0.1$.</li>
</ul>
</li>
<li>如果箱子里面不含有第4类。第2,3类每个物品的bonus最多是0.1, 最多装5个, 因此总的bonus不会超过0.5.</li>
</ul>
<h4 id="Part2-算法解除掉最后2个箱子-剩下的箱子平均权重至少是1"><a href="#Part2-算法解除掉最后2个箱子-剩下的箱子平均权重至少是1" class="headerlink" title="Part2: 算法解除掉最后2个箱子, 剩下的箱子平均权重至少是1."></a>Part2: 算法解除掉最后2个箱子, 剩下的箱子平均权重至少是1.</h4><p>首先我们拿掉算法解中本来权重就至少是1的箱子, 剩下箱子$B_1 \cdots B_m$, 那么剩下的箱子满足:</p>
<ol>
<li>不含第4类物品。 因为第四类物品的权重至少是1.</li>
<li>不会同时含2个第3类物品。 因为任意2个第3类物品的权重之和至少是1.</li>
<li>$s(B_i) \lt \frac{5}{6}$, 否则权重不算bonus部分就至少是1了。</li>
<li>除了最后1个箱子, 剩下的箱子里面至少装了2个物品。 因为First Fit优先放前面的箱子，而物品体积都不超过0.5, 一个箱子至少可以放2个物品。</li>
<li>除了最后2个箱子, 剩下的箱子装的物品总体积$\gt \frac{2}{3}$. 假设有一个箱子$\geq \frac{2}{3}$, 那么在它后面的箱子里面装的物品体积都$\in(\frac{1}{3}, \frac{1}{2})$, 也就是都是第3类物品。 根据(4)它后面的箱子除了最后一个箱子每个箱子至少装了2个物品，且都是第3类物品，那么就违反了(2).</li>
</ol>
<p><strong>Lemma</strong>: $\forall 1 \leq i \leq m-2, s(B_i) + bonus(B_{i+1}) \geq 1$.<br>证明:<br>设$B_{i+1}$中体积最小的物品体积是$x$, 根据first fit有$s(B_i) + x \gt 1$.</p>
<ul>
<li>因为$s(B_i) \lt \frac{5}{6}$, $x \gt \frac{1}{6}$。</li>
<li>因为$B_{i+1}$中不能有2个$\geq \frac{1}{3}$的物品, 且$B_{i+1}$装了至少2个物品, $x \lt \frac{1}{3}$. </li>
<li>综合上面2条有</li>
</ul>
<p>$$<br>\begin{aligned}<br>&amp;\quad \frac{6}{5}s(B_i) + bonus(B_{i+1}) \<br>&amp;\geq  \frac{6}{5}s(B_i) + 2bonus(x) \<br>&amp;&#x3D; \frac{6}{5}s(B_i) + \frac{6}{5}(x-\frac{1}{6})\<br>&amp;&#x3D; \frac{6}{5}(s(B_i)+x) - \frac{1}{5} \gt 1<br>\end{aligned}<br>$$</p>
<p>利用上面的引理<br>$$<br>\begin{aligned}<br>\sum_{i&#x3D;1}^m{w(B_i)}  &amp;&#x3D; \sum_{i&#x3D;1}^m{(\frac{6}{5}s(B_i)+ bonus(B_i))} \<br>&amp;&#x3D; bouns(B_1) + \sum_{i&#x3D;1}^{m-2} {(\frac{6}{5}s(B_i) + bonus(B_{i+1}))} + \frac{6}{5}(s(B_{m-1}) + s(B_{m})) + bouns(B_m) \<br>&amp;\geq m-2 + \frac{6}{5}<br>\end{aligned}<br>$$<br>因此有$\sum_{i&#x3D;1}^m{w(B_i)}+0.8 \geq m$.</p>
<p>结合两个part, 得到$ALG-0.8 \leq w(I) \leq 1.7OPT$, 也就证明了 $ALG \leq 1.7OPT+0.8$.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/12/29/Coding-Theory-Expander-Codes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/29/Coding-Theory-Expander-Codes/" class="post-title-link" itemprop="url">Coding Theory-Expander Codes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 19:47:05" itemprop="dateCreated datePublished" datetime="2019-12-29T19:47:05+00:00">2019-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding-Theory/" itemprop="url" rel="index"><span itemprop="name">Coding Theory</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Expander Code是一种特殊的Linear Code, 特殊之处在于它的check matrix对应某个**(bipartite) expander graph**的临接矩阵.  这样一来，编码的一些性质(如距离、解码)就可以和图的性质对应起来。</p>
<p>为了只会阐述方便，我们先约定一些记号:</p>
<ol>
<li>用$G(L \cup R, E)$表示一个二分图, $L, R$分别表示左右两个点集。</li>
<li>定义点集$S$的邻居$N(S):&#x3D;{v| v \text{ is incident to some vertex } u\in S }$.</li>
<li>定义点集$S$的唯一邻居$U(S) :&#x3D;{v| v \text{ is incident to exactly one vertex } u\in S }$</li>
<li><strong>$d$-regular graph</strong>: 每个点的度都是$d$的图。</li>
<li><strong>$d$-left-regular graph</strong>:二分图的左边每个点的度都是$d$. 同理有**$d$-right-regular graph**.</li>
</ol>
<h3 id="Factor-Graph-of-Linear-Code"><a href="#Factor-Graph-of-Linear-Code" class="headerlink" title="Factor Graph of Linear Code"></a>Factor Graph of Linear Code</h3><p>给定一个$[n, k]$ <strong>Binary</strong> Linear Code $C \subset F_2^n$和它的一个check matrix $H$, 我们可以按照下面的方式构造一个二分图:<br>$|L|&#x3D;n, |R| &#x3D; n-k$. 左边的每个点对应codeword的一个bit。右边的每个点对应check matrix的一行。为方便起见，左边的点集记作${u_1, u_2 \cdots, u_n}$, 右边的点集记作${v_1, v_2 \cdots v_{n-k}}$<br>要判断一个向量$x$是否属于$C$, 只需要给左边的点集分配一个权重: $w(u_i) &#x3D; x_i$。 $x \in C$当且仅当<br>$$<br>\forall v_i \in R, \sum_{u_j \in N(v_i)}{w(u_j)} &#x3D; 0<br>$$<br>这个过程本质上就是$u$和$H$的每行的点积都是0.   如上构造的图称为$C$的 <strong>Factor Graph</strong>.</p>
<h3 id="Expander-Graphs-and-Expander-Codes"><a href="#Expander-Graphs-and-Expander-Codes" class="headerlink" title="Expander Graphs and Expander Codes"></a>Expander Graphs and Expander Codes</h3><p>定义$(n, m, d, \gamma, \alpha)$ <strong>Bipatite Expander</strong> 是一个$d$-left-regular的二分图, 满足$|L|&#x3D;n, |R|&#x3D;m$并且$\forall S \subset L$, 如果$|S| \leq \gamma n$, 那么有$ N(S) \geq \alpha |S|$.<br>也就是说，从左边取一个”足够小”的集合，它的邻居集合一定”足够大”.<br><strong>Expand Codes</strong>就是一种特殊的线性码，它的factor graph正好是一个bipatite expander。因为其特殊的结构，我们更加容易分析它的最小距离，以及可以更快的编码&#x2F;解码。</p>
<p>下面先证明一个引理:</p>
<p><strong>引理1:</strong> 如果$G$是一个$(n, m, d, \gamma, (1-\epsilon)d)$的bipartite expander($\epsilon \lt 0.5$), 那么$\forall S\subset L$, 如果$|S| \leq \gamma n$, 那么有$|U(S)| \geq d(1-2\epsilon)|S| \gt 0$ 。<br>后面估计expander code的最小距离的时候会用到$|U(S)| \neq 0$这个性质。</p>
<p>证明:<br>首先根据bipartite expander的定义有$N(S) \geq (1-\epsilon)d|S|$. 因为$S$中每个点都和右边的$d$个点相连, 一共有$d|S|$条边, 其中有$|N(S)|$条为增加邻居数做出了贡献, 剩下的$d|S|- |U(S)|$条边, 每条边可能使得某个邻居变得不”唯一”(见introduction里唯一邻居的定义).<br>因此$|U(S)|\geq |N(S)|- (|d|S|-|N(S)|) &#x3D; 2|N(S)|-d|S| \geq d(1-2\epsilon)|S|$.</p>
<p>利用上面的引理, 可以给出expander code的最小距离的一个下界。<br><strong>定理1:</strong> 如果线性码$C$的factor graph $G$是一个$(n, m, d, \gamma, (1-\epsilon)d)$的bipartite expander, 那么$d(C) \geq 2\gamma (1-\epsilon)n$.</p>
<p>证明:<br>根据线性码的性质，只需要证明重量最小的codeword重量不会小于$2\gamma (1-\epsilon)n$.<br>假设有一个codeword $r \in C$, $wt(r) \lt 2\gamma (1-\epsilon)n$.  按之前判断向量是否属于$C$的方法给左边的点分配权值:$w(u_i) &#x3D; r_i$.  令$S :&#x3D; {u_i| r_i &#x3D; 1 }$, $U(S)$中的parity check条件不可能被满足，因为每个条件只对应左边一个1。所以我们只要证明$U(S)$非空，即可推出矛盾。</p>
<ul>
<li>如果$|S| \leq \gamma n$, 根据上面的引理直接可以推出$U(S)$非空。</li>
<li>如果$|S| \gt \gamma n$, 那么可以找到$S$的一个子集$S’$, $|S’| &#x3D; \gamma n$, 根据引理$|U(S’)| \geq d(1-2\epsilon)\gamma n$.  考虑$U(S’)$中的哪些点不属于$U(S)$, 一定是因为有些 $S \backslash S’$中的那些点又连边到$U(S’)$中的点, 破坏了它们的”唯一性”.  因为$|S| &#x3D; wt(r) \lt 2\gamma(1-\epsilon)n$, 所以$|S\backslash S’| \lt (1-2\epsilon)n$。最多破坏$d|S\backslash S’|\lt d(1-2\epsilon)\gamma n \leq |U(S’)|$这么多点的”唯一性”,  因此至少还存在一些$U(S’)$中的点属于$U(S)$.</li>
</ul>
<h3 id="Encoding-Algorithm-for-Expander-Codes"><a href="#Encoding-Algorithm-for-Expander-Codes" class="headerlink" title="Encoding Algorithm for Expander Codes"></a>Encoding Algorithm for Expander Codes</h3><p>Expander Code的encoding和线性码是一样的，只需要做一次矩阵乘法, 时间复杂度是$O(n^2)$. [3]目前已经有可以做到$O(n)$时间的算法.</p>
<h3 id="Decoding-Algorithm-for-Expander-Codes"><a href="#Decoding-Algorithm-for-Expander-Codes" class="headerlink" title="Decoding Algorithm for Expander Codes"></a>Decoding Algorithm for Expander Codes</h3><p>假设$C$对应$(n, m, d, \gamma, (1-\epsilon)d)$ expander, 且满足$\epsilon \lt \frac{1}{4}$。 当收到向量$r$, 错误位数小于$\gamma(1-2\epsilon)n$的时候，可以用下面的算法恢复:</p>
<ol>
<li>给左边的点赋权值, $w(u_i) :&#x3D; r_i$.</li>
<li>找到某个$u_i \in L$, $N(u_i)$中不满足parity check 条件的比满足的多。如果找不到，算法结束。</li>
<li>反转$r$的第$i$个bit, 相应地，反转$w(u_i)$. 跳到第2步。</li>
</ol>
<p>通俗地讲，就是依次检查每个bit, 如果某个bit对应的parity check条件不满足的个数要比满足的多，那么反转这个bit，可以使得满足的parity check条件变多, 显然算法会在有限步内终止。 假设实际发送的是$r’, d(r, r’) \lt \gamma(1-2\epsilon)n$.   要证明算法可行，我们要证明两件事:</p>
<ol>
<li><p>如果算法返回的解$\in C $，那么一定是和$r$距离最近的那个, 即实际发送的$r’$.  我们只要证明任意时刻$d(r, r’) \leq \gamma n \lt d(C)$, 也就是说算法执行过程中$r$不会偏离$r’$太远.<br>证明:<br>因为$r’$满足所有parity check条件, 一开始$d(r, r’) \lt \gamma(1-2\epsilon)n$, 不满足的parity check条件数$\lt d(1-2\epsilon)\gamma n$.  而在算法执行的过程中，不满足的parity check条件只会越来越少。<br>假设某时刻发生了$d(r, r’) \gt \gamma n$.  因为算法每次迭代只会改变一个bit, 那么一定存在一个时刻$d(r, r’) &#x3D; \gamma n$.  设$S:&#x3D;{i|r_i \neq r_i’}$, 由引理1 $|U(S)| \geq d(1-2\epsilon)\gamma n$, 且$U(S)$对应的parity check条件都是没有满足的。 因此又得出不满足的parity check条件数至少是$d(1-2\epsilon)\gamma n$, 导致矛盾。</p>
</li>
<li><p>算法不会在某一步”卡主”. 也就是说，不会存在某个极端的情况，对于$\forall u_i, N(u_i)$中满足parity check条件的和不满足的恰好一样多。  我们证明，如果$d(r, r’) \leq \gamma n$, 一定存在一个$u_i \in L$, $N(u_i)$中不满足parity check条件的个数大于$d&#x2F;2$(自然$N(u_i)$中不满足的多于满足的).<br>证明:<br>令$S:&#x3D;{i|r_i \neq r_i’}$, $|S| \leq \gamma n$, 根据引理1有$|U(S)| \geq d(1-2\epsilon)|S| \gt \frac{d}{2}|S|$ (这里用到$\epsilon \lt \frac{1}{4} $). 根据鸽笼原理$S$中一定存在一个点$u_i$, $U(S)$中和$u_i$相连的点大于$d&#x2F;2$, 这些点对应的parity check条件都是不满足的。</p>
</li>
</ol>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ol>
<li>Notes from CMU, <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~venkatg/teaching/codingtheory/notes/notes8.pdf">https://www.cs.cmu.edu/~venkatg/teaching/codingtheory/notes/notes8.pdf</a> </li>
<li>Wikipedia <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Expander_code">https://en.wikipedia.org/wiki/Expander_code</a> </li>
<li>Spielman, D. (1996). “Linear-time encodable and decodable error-correcting codes”. IEEE Transactions on Information Theory. 42 (6): 1723–31. CiteSeerX 10.1.1.47.2736. doi:10.1109&#x2F;18.556668.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/12/26/Coding-Theory-Some-Bounds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/26/Coding-Theory-Some-Bounds/" class="post-title-link" itemprop="url">Coding Theory-Some Bounds</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-26 10:26:55" itemprop="dateCreated datePublished" datetime="2019-12-26T10:26:55+00:00">2019-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding-Theory/" itemprop="url" rel="index"><span itemprop="name">Coding Theory</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节主要介绍关于编码的一些上下界。</p>
<h3 id="The-Main-Coding-Theory-Problem"><a href="#The-Main-Coding-Theory-Problem" class="headerlink" title="The Main Coding Theory Problem"></a>The Main Coding Theory Problem</h3><p>定义$A_q(n, d)$为长度为$n$, 最小距离是$d$的编码, size最大能是多少。$B_q(n, d)$为长度为$n$, 最小距离是$d$的线性码, size最大能是多少。 确定它们的值或者上下界成为<strong>The Main Coding Theory Problem</strong>.</p>
<p>首先是几个非常trivial的bound:</p>
<ol>
<li>$B_q(n, d) \leq A_q(n, d) \leq q^n$.</li>
<li>$B_q(n, 1) &#x3D; A_q(n, 1) &#x3D; 1$.</li>
<li>$B_q(n, n) &#x3D; A_q(n, n) &#x3D; n$.</li>
</ol>
<p>前两个非常显然, 最后一个因为$d&#x3D;n$, 那么每个codeword的任意位互不相同。 只考虑第一位互不相同，最多就只能选$n$个codeword。因此上界是$n$. 而${(a, a, \cdots, a) \mid a \in F_q}$就可以达到$n$.</p>
<p>下面引入一个<strong>extended code</strong>的概念:<br>$$<br>\overline{C} :&#x3D; {(c_1, c_2, \cdots, c_n, -\sum_{i&#x3D;1}^n{c_i}) \mid (c_1, c_2, \cdots, c_n) \in C}<br>$$<br>就是在最后增加一位, 是前面的所有位的和取负。设$H$是$C$的check matrix, 容易验证$\overline{C}$的一个check matrix $\overline{H}&#x3D;<br>\begin{pmatrix}<br>\          &amp; 0  \<br>H         &amp; \vdots \<br>\         &amp; 0  \<br>1  \cdots 1       &amp; 1<br>\end{pmatrix}$</p>
<p><strong>Theorem 1:</strong> 假设$d$是一个奇数。</p>
<ol>
<li>存在$(n, M, d)_2$-code当且仅当存在$(n+1, M, d+1)_2$-code. $A_2(n, d) &#x3D; A_2(n+1,d+1)$.<br>证明：<br>假设$C$是$(n, M, d)_2$-code, 考虑它的extended code $\overline{C}$. 显然$d \leq d(\overline{C}) \leq d+1$. 考虑任意$u,v \in C, d(u, v) &#x3D; d$. 由于$d$是奇数, $\overline{u}, \overline{v}$除了$u,v$不同的位置不同, 最后一位扩展位也不同。因此$d(\overline{u}, \overline{v}) &#x3D; d+1$.  从而说明$\overline{C}$是$(n+1, M, d+1)_2$-code.<br>反过来，如果$C$是$(n+1, M, d+1)_2$-code, 那么存在$u,v \in C, d(u, v)&#x3D;d+1$. 找到$u,v$不相同的某一位， 把$C$中所有codeword删去这一位, 得到新的码$C’$。 因为只删去了一位，那么距离最多减少1，因此$d(C’) \geq d$, 而$d(u’, v’)&#x3D;d$, 所以$d(C’) &#x3D; d$.  </li>
<li>存在$[n, M,d]_2$-code当且仅当存在$[n+1, M, d+1]$-code.  $B_2(n, d) &#x3D; B_2(n+1,d+1)$.<br>证明：<br>如果$C$是linear code, 那么$\overline{C}$也是，必要性得证。<br>如果$C$是$[n+1, M, d+1]_2$-code, 那么存在$x \in C, wt(x) &#x3D; d+1$. 选择$x$非0的某一位, 把$C$中所有codeword删去这一位, 得到新的码$C’$, 显然$C’$也是linear code. 之后同上一条去掉某一位的论证。</li>
</ol>
<h3 id="Some-Lower-Bounds"><a href="#Some-Lower-Bounds" class="headerlink" title="Some Lower Bounds"></a>Some Lower Bounds</h3><p>本节主要讨论关于$A_q(n, d), B_q(n, d)$的一些下界。</p>
<h4 id="Sphere-Covering-Bound"><a href="#Sphere-Covering-Bound" class="headerlink" title="Sphere-Covering Bound"></a>Sphere-Covering Bound</h4><p>定义$S(u, r):&#x3D; {v \in C \mid d(u,v) \leq r }$. 显然$|S(u, r)| &#x3D; \sum_{i&#x3D;0}^{r} \binom{n}{i}(q-1)^i$. 也就是以$u$为圆心，$r$为半径的球。<br>考虑达到最优大小$A_q(n,d)$的码$C$, $|C| &#x3D; A_q(n, d)$, 有$\bigcup_{u \in C}{S(u, d-1)} &#x3D; F_q^n$. 因为如果这些球并起来不是整个空间，那么存在一个点不在任意一个球内，这个点和$C$内的任意codeword距离都至少是$d$, 那么这个点加入$C$可以得到更大的码。所以有<br>$$<br>A_q(n, d) \geq \frac{q^n}{\sum_{i&#x3D;0}^{d-1} \binom{n}{i}(q-1)^i}<br>$$</p>
<h4 id="Gilbert–Varshamov-Bound"><a href="#Gilbert–Varshamov-Bound" class="headerlink" title="Gilbert–Varshamov Bound"></a>Gilbert–Varshamov Bound</h4><p><strong>Theorem:</strong><br>如果<br>$$<br>\sum_{i&#x3D;0}^{d-2} \binom{n-1}{i}(q-1)^i \lt q^{n-k}<br>$$<br>那么存在$[n, k]$ linear code $C$, $d(C) \geq d$.<br>证明:<br>考虑构造一个$(n-k) \times n$的”check matrix” $H$, 这里加引号是因为并不要求$H$的行是线性无关的, 但是任意$d-1$列是线性无关的。那么$H$的null space对应的就是一个维数至少是$k$, 距离至少是$d$的线性码。任取generator matrix $G$的$k$行就可以得到维数恰好是$k$, 距离至少是$d$的线性码。<br>下面考虑一列一列构造这样的$H$:</p>
<ol>
<li>随便选一个$u_1 \in F_q^{n-k}$, 作为第1列。</li>
<li>对$2\leq i \leq n$, 选取$u_i$作为第$i$列, 要求$u_i$不能使${u_1, u_2, \cdots, u_{i-1}}$中任意$d-2$个的线性组合。<br>显然如果构造顺利, 我们就找到了符合要求的$H$, 但是我们还得证明第二步中一定存在一个符合要求的$u_i$.<br>因为${u_1, u_2, \cdots, u_{i-1}}$中任意$d-2$个的线性组合构成的空间大小不超过<br>$$<br>\sum_{j&#x3D;0}^{d-2} \binom{i-1}{j}(q-1)^j \leq \sum_{j&#x3D;0}^{d-2} \binom{n-1}{j}(q-1)^j \lt q^{n-k}<br>$$<br>所以每次总能找到符合要求的$u_i$.</li>
</ol>
<h3 id="Hamming-Bound"><a href="#Hamming-Bound" class="headerlink" title="Hamming Bound"></a>Hamming Bound</h3><h4 id="Binary-Hamming-Code"><a href="#Binary-Hamming-Code" class="headerlink" title="Binary Hamming Code"></a>Binary Hamming Code</h4><p><strong>Binary Hamming Code</strong>是一种特殊的linear code, 它的长度是$2^r-1$, check matrix $H$大小是$r \times (2^r-1)$每一列恰好是$1, 2 \cdots (2^r-1)$的二进制表示。<br>首先我们验证一下$H$的行线性无关: 一共$r$行, 考虑$(0, \cdots, 0, \underbrace{1}_{i^{th} bit}, 0, \cdots, 0)^T$所在的列, 这一列只有一个$1$. 一共有$r$由单个$1$组成的列，且这些列的$1$所在的行都不一样。显然这$r$行线性无关。</p>
<p>下面是Binary Hamming Code的一些性质。<br>如果$C$是Binary Hamming Code, check matrix $H$大小是$r \times (2^r-1)$, 记作$Ham(r, 2)$.</p>
<ol>
<li>$dim(Ham(r, 2)) &#x3D; 2^r-1-r$。</li>
<li>$d(Ham(r, 2)) &#x3D; 3$. 因此只能恢复一个错误。<br>证明:<br>根据linear code的性质, 只要证明$H$任意$2$列线性无关，存在$3$列线性相关。前者显然, 因为任意两列互不相同。后者只要取$(1, 0, 0, \cdots ,0)^T, (0, 1, 0, \cdots ,0)^T, (1, 1, 0, \cdots, 0)^T$所在的列。</li>
</ol>
<p>Binary Hamming Code的Decoding也可以沿用linear code的Syndrome Decoding那一套。<br>$e_j :&#x3D; (0,\cdots ,0, \underbrace{1}<em>{j^{th} bit}, 0, \cdots, 0)$, $H &#x3D; (h_1, h_2, \cdots, h</em>{2^r-1})$, 则$e_j H^T &#x3D; h_j$.<br>如果收到的$w$只有$1$个错误, 那么$wH^T$恰好就是$H$的某一列，假设是第$k$列, 那么出错的就是第$k$位。</p>
<h4 id="Extended-Binary-Hamming-Code"><a href="#Extended-Binary-Hamming-Code" class="headerlink" title="Extended Binary Hamming Code"></a>Extended Binary Hamming Code</h4><p>扩展海明码记作$\overline{Ham(r, 2)}$, 定义见线性码的扩展，就是在最后增加一位parity check位。<br>因为$Ham(r, 2)$是$(n, M, 3)$-code, 所以根据Theorem 1的证明, $Ham(r, 2)$是$(n+1, M, 4)$-code, $d(\overline{Ham(r, 2)}) &#x3D; 4$.</p>
<h4 id="Weight-Distribution-Of-Hamming-Code"><a href="#Weight-Distribution-Of-Hamming-Code" class="headerlink" title="Weight Distribution Of Hamming Code"></a>Weight Distribution Of Hamming Code</h4><p><a target="_blank" rel="noopener" href="http://oeis.org/wiki/List_of_weight_distributions#Hamming_codes">部分重量分布表</a><br>如何计算？<br>我们知道Hamming Code的check matrix $H$, 可以计算出$C^{\perp}$的重量分布，再利用<a target="_blank" rel="noopener" href="https://www.encyclopediaofmath.org/index.php/MacWilliams_identities">MacWilliams’ Identity</a>计算出$C$的分布.<br>也可以通过$Hx &#x3D; 0$计算出generator matrix $G$, 直接计算$C$的重量分布。<br>通过观察可以发现$A_i &#x3D; A_{n-i}$. 因为$H$的每行都有偶数个$1$, 如果$uH^T &#x3D; 0$, 那么$\overline{u}H^T &#x3D; 0$, $\overline{u}$是$u$的每一位取反。</p>
<h3 id="Singleton-Bound-and-MDS-Codes"><a href="#Singleton-Bound-and-MDS-Codes" class="headerlink" title="Singleton Bound and MDS Codes"></a>Singleton Bound and MDS Codes</h3><h4 id="Singleton-Bound"><a href="#Singleton-Bound" class="headerlink" title="Singleton Bound"></a>Singleton Bound</h4><p>Singleton Bound: $A_q(n, d) \leq q^{n-d+1}$.<br>证明: 任意编码$C$, 满足$d(C) &#x3D; d$, 考虑删掉所有codeword的最后$d-1$位, 那么它们还是互不相同的. 而长度为$n-d+1$的codeword只有$q^{n-d+1}$个, 所以$|C| \leq q^{n-d+1}$.<br>另外, 如果$C$是$[n, k, d]$-linear code, 可以推出$|C|&#x3D;q^k \leq q^{n-d+1} \rightarrow k+d \leq n+1$.</p>
<h4 id="MDS-Codes"><a href="#MDS-Codes" class="headerlink" title="MDS Codes"></a>MDS Codes</h4><p>MDS Codes就是使得Singleton Bound取等号的编码。</p>
<p>Theorem 2:<br>设$C$是$[n, k, d]$-linear code, 以下几条等价:</p>
<ol>
<li>$C$是MDS Code.</li>
<li>check matrix $H$的任意$n-k$列线性无关。</li>
<li>generator matrix $G$的任意$k$行线性无关。</li>
<li>$C^{\perp}$是MDS code.</li>
</ol>
<p>证明:</p>
<ul>
<li>(1),(2)显然等价。</li>
<li>把$G$看做$C^{\perp}$的check matrix, 推出(3),(4)等价。</li>
<li>(1)推出(4). 只要证明$d(C^{\perp})&#x3D;k+1$. 假设存在$u \in C^{\perp}, wt(u) \leq k$. 也就是说$u$至少有$n-k$个分量是0. 因为$H$是$C^{\perp}$的generator matrix, 所以存在$(n-k) \times 1$的向量$v$, 满足$u &#x3D; vH$. 设$J :&#x3D; {j \mid u_j &#x3D; 0}$, 令$J’$是$J$的一个大小为$n-k$的子集, $H_{J’}$是取出$J’$对应的那些列的构成的矩阵($(n-k) \times (n-k)$ ). 由(2)$H_{J’}$是满秩的, $0 &#x3D; u_{J’} &#x3D; vH_{J’}$, 可以推出$v &#x3D; 0$, 从而$u &#x3D; 0$.  因此不存在$u, wt(u) \leq k$, 也就是说$d(C^{\perp}) \geq k+1$.</li>
<li>$C&#x3D;(C^{\perp})^{\perp}$, 同上(4)可以推出(1).</li>
</ul>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/12/22/Coding-Theory-Linear-Code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/22/Coding-Theory-Linear-Code/" class="post-title-link" itemprop="url">Coding Theory-Linear Code</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-22 22:42:05" itemprop="dateCreated datePublished" datetime="2019-12-22T22:42:05+00:00">2019-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding-Theory/" itemprop="url" rel="index"><span itemprop="name">Coding Theory</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>编码的目的：将信息通过某种方式编码后传输(比如ASCII码将字母变成8位01串)，使之满足下面的某些性质：</p>
<ul>
<li>编码速度快。</li>
<li>编码结果易于传输。</li>
<li>解码速度快。</li>
<li>极大化信息传输率(可以理解为用尽可能少的长度表示尽可能多的信息)。</li>
<li>检测&#x2F;纠正传输错误。</li>
</ul>
<h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><h4 id="Notations"><a href="#Notations" class="headerlink" title="Notations"></a>Notations</h4><ul>
<li><strong>code alphabet</strong>. 用于编码的字符集, 字符集中的元素成为<strong>code symbol</strong>, 一般用$q$表示字符集的大小。</li>
<li>通常用字母<strong>C</strong>表示编码的集合，其中的元素成为<strong>codeword</strong>, 每个codeword可以看做是长度为$n$的向量, 向量的每个分量取值来自code alphabet。</li>
<li><strong>(n, M) code</strong>. 长度为$n$, 元素个数为$M$的编码集合。</li>
<li><strong>Information rate</strong>.  $\frac{\log_q{|C|}}{n}$</li>
</ul>
<h4 id="Hamming-Distance"><a href="#Hamming-Distance" class="headerlink" title="Hamming Distance"></a>Hamming Distance</h4><p>Hamming distance $d(x, y)$：逐位比较$x, y$的每一位, 有多少位不同, 即$d(x, y) &#x3D; \sum_{i&#x3D;1}^n[x_i\neq y_i]$。<br>最重要的一点，Hamming距离是满足三角形不等式的, 即$d(x, y) \leq d(x, z) +d(z, y)$.<br>证明: </p>
<p>实际上Hamming distance对应向量的一范式($d(x, y)&#x3D;|x-y|<em>1$), 可以参考关于向量范式的三角形不等式的证明。不过我们没有定义两个码的减法操作。<br>因为<br>$$<br>d(x, y) &#x3D; \sum</em>{i&#x3D;1}^n[x_i\neq y_i]<br>$$<br>$$<br>d(x, z) +d(z, y)&#x3D;\sum_{i&#x3D;1}^n ([x_i\neq z_i] + [y_i \neq z_i])<br>$$<br>所以只要证明$[x_i \neq y_i] \leq [x_i\neq z_i] + [y_i \neq z_i]$.<br>如果$x_i &#x3D; y_i$显然成立。<br>如果$x_i \neq y_i$, 左边是1，右边不管$z_i$取0还是1，总有一个是1.<br>定义编码的距离</p>
<p>$$<br>d(C) :&#x3D; \min_{x,y \in C}{d(x,y)}<br>$$</p>
<h3 id="Linear-Code"><a href="#Linear-Code" class="headerlink" title="Linear Code"></a>Linear Code</h3><p>线性码就是说$C$是一个线性空间, $C$中的codeword满足线性空间的加法减法数乘的封闭性等。</p>
<p>一般的, 我们默认取线性空间$V:&#x3D;F_q^n$, 也就是说$C$中的codeword是$n$维向量，向量的每一维取自有限域$F_q$. </p>
<p>$C$是线性码当且仅当满足线性空间的八条性质。$\forall u, v, w\in C, \lambda, \mu \in F_q$ 满足:</p>
<ol>
<li>$u+v \in C$.</li>
<li>$(u+v)+w &#x3D; u+(v+w)$.</li>
<li>存在零元$0 \in C$, $0+v&#x3D;v+0&#x3D;v$.</li>
<li>$u+v&#x3D;v+u$.</li>
<li>$\lambda u \in C$.</li>
<li>$\lambda(u+v) &#x3D; \lambda u + \lambda v$.</li>
<li>$(\lambda \mu) u &#x3D; \lambda (\mu u)$.</li>
<li>设$1$是$F_q$的单位元, $1u&#x3D;u$.</li>
</ol>
<p>另外有一个小定理，在之后经常会用到:</p>
<p>设$C$是定义在$F_q$上的线性空间$V$的一个非空集合，$C$是 $V$的子空间当且仅当<br>$$<br>\forall \lambda,\mu \in F_q, u,v\in C, \lambda u+ \mu v \in C<br>$$ </p>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><ol>
<li>定义$C$的正交补码$C^{\perp}:&#x3D; {v \in F_q^n, v\cdot u &#x3D; 0 \ \ \forall s \in C}$. 容易验证$C^{\perp}$也是线性码, 且$(C^{\perp})^{\perp} &#x3D; C$</li>
<li>${&lt;}S{&gt;}$表示$S$生成的子空间。 用线性代数的知识很容易证明$dim({&lt;}S{&gt;})+dim(S^{\perp}) &#x3D; n$.</li>
<li>定义某个codeword的重量$w(x)$为$x$非0的分量个数。容易证明$d(C):&#x3D; \min_{x \in C}{w(x)}$.<br>证明:  <ul>
<li>若$d(C) &#x3D; d(x, y)$, 那么$x-y \in C$, 因此$d(C) &#x3D; w(x-y) \geq \min_{x \in C}{w(x)}$.</li>
<li>反过来,  设$w(x_0) &#x3D; \min_{x \in C}{w(x)}$, $ d(C) \leq d(x_0, 0) &#x3D; w(x_0) &#x3D; \min_{x \in C}{w(x)}$.</li>
</ul>
</li>
<li>用$[n, k]$-linear code表示长度为$n$, 维度为$k$的线性码。</li>
</ol>
<p>​    </p>
<h4 id="Generator-Matrix-Check-Matrix"><a href="#Generator-Matrix-Check-Matrix" class="headerlink" title="Generator Matrix, Check Matrix"></a>Generator Matrix, Check Matrix</h4><ul>
<li>线性码$C$的**generator matrix  **$G$: 大小为$k*n$, $k&#x3D;dim(C)$, $k$行恰好是$C$的一组基。</li>
<li>线性码$C$的**check matrix ** $H$, 大小为$(n-k)*n, k &#x3D; dim(C)$, $n-k$行恰好是$C^{\perp}$的一组基。容易验证$HG^T &#x3D; GH^T &#x3D; 0$.</li>
</ul>
<p>下面是一些有用的性质，有些证明我个人认为比较简单，就略去了。</p>
<p><strong>性质1:</strong><br>$v \in C^{\perp}  \Longleftrightarrow vG^T &#x3D; 0$.<br>简单地说，就是一个向量和$C$中所有向量点积为0当且仅当它和一组基里的所有向量点积为0.<br>同理有$v \in C  \Longleftrightarrow vH^T &#x3D; 0$. </p>
<p><strong>性质2：</strong><br>一个$(n-k)*n$的矩阵$H$是check matrix当且仅当$H$的行线性无关，并且$HG^T &#x3D; 0$.</p>
<p><strong>性质3：</strong><br>假设$H$是线性码$C$的check matrix。$d(C) &#x3D; d$当且仅当$H$的任意$d-1$列线性无关, 存在$d$列线性相关。<br>证明：<br>设$h_i$表示$H$的第$i$, $v\in C$, $w(v)&#x3D;e$,  ${i_1, i_2, \cdots, i_e}$是$v$非零分量的下标。<br>根据性质1有$0 &#x3D; vH^T &#x3D; \sum_{j&#x3D;1}^e v_{i_j}h_{i_j}^T$, 这意味着${h_{i_j}}$是线性相关的。<br>因为$d(C) &#x3D; \min_{v \in C}{w(v)}$, 因此$H$存在$d(C)$列线性相关.<br>假设$H$的第 ${i_1, i_2, \cdots, i_e}$列线性无关,  即存在一组数${a_j}$, $\sum_{j&#x3D;1}^e a_jh_{i_j} &#x3D; 0$. 容易构造一个向量$v$, 使$v_{i_j} &#x3D; a_j$, 其它分量为0. $v \in C, w(v) &#x3D; e$.   由此可以推出$H$的任意少于$d(C)$列都是线性无关的, 否则按我们的方法就可以构造出相应的$v \in C$ , $w(v) \lt d(C)$.</p>
<p>反过来，假设$H$的任意$d-1$列线性无关, 存在$d$列线性相关。因为任意$d(C)-1$列线性无关, 所以$d(C)-1 \leq d-1$, 即$d(C)\leq d$.  因为存在$d(C)$列线性相关，所以$d(C) \gt d-1$, 即$d(C) \geq d$.</p>
<h4 id="Encoding-and-Decoding-with-a-Linear-Code"><a href="#Encoding-and-Decoding-with-a-Linear-Code" class="headerlink" title="Encoding and Decoding with a Linear Code"></a>Encoding and Decoding with a Linear Code</h4><h5 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h5><p>取$k*n$的generator matrix $G$, 定义线性码的加密是映射$F^k_q \rightarrow F_q^n$, 将$k$维向量$u$映射到$n$维向量$uG$. 可以看做是用$G$的各行的线性组合。 </p>
<p>值得一提的是，一般取$G&#x3D;(I|X)$这样的矩阵(<strong>generator matrix in standard form</strong>)。这样$uG &#x3D; (u, uX)$, 前面$k$位就是原来的信息(<strong>message digits</strong>)，后面$n-k$位是冗余信息(<strong>check digits</strong>)，可以用来修正传输时候的噪声。注意编码学不同于密码学，密码学注重信息的安全性，而编码学关注去除传输时出现的噪声 (某些位在传输过程中出现了变化)。</p>
<h5 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a>Decoding</h5><p>解码稍微要复杂一些，因为要考虑到传输过程中出现的错误。<br>假设传输的是$u$, 收到的是$v$.  定义错误向量$e &#x3D; v-u$。 根据最近邻居解码原则, 我们认为$e$是使得$v+e\in C$并且$w(e)$最小的(出错的位数最少)。<br>在这个原则下，提出下面的算法。</p>
<p><strong>算法1：</strong></p>
<p>预处理出所有的coset(涉及一些抽象代数),  即形如$u+C$的集合, $u \in F_q^n$.<br>$e &#x3D; v-u \in v + C$, 因此我们查表找到$v$所在的coset中权值最小的向量就是$e$.利用$u &#x3D; v-e$复原。<br>这样做需要很大的空间，因为得把$F_q^n$里$q^n$这么多向量全部存下来，只有当$q^n$比较小的时候才可行。</p>
<p><strong>算法2:</strong></p>
<p>终于轮到我们之前提了半天的check matrix $H$出场了。<br>因为$\forall v \in u+C, vH^T &#x3D; (u+w)H^T &#x3D; uH^T+vH^T &#x3D; uH^T$. 也就是说，同一个coset里的向量，右乘上$H^T$的结果是一样的。<br>所以我们只要保存每个coset权值最小的向量, 以及coset中的元素右乘$H^T$的结果就可以用算法1的方法解码。存储的空间之和coset个数有关，而根据每个coset的大小都是$q^k$, coset的个数就是$q^{n-k}$，比算法1的$q^n $要好。<br>这种算法称为<strong>Syndrome decoding</strong>, $u$的syndrome记作$S(u):&#x3D; uH^T$。</p>
<h4 id="Weight-Distribution"><a href="#Weight-Distribution" class="headerlink" title="Weight Distribution"></a>Weight Distribution</h4><p>$A_i :&#x3D;  |{ u \mid wt(u)&#x3D;i }|$.<br>$W_c(x, y) &#x3D; \sum_{i&#x3D;0}^n{A_ix^iy^{n-i}}$.<br><a target="_blank" rel="noopener" href="https://www.encyclopediaofmath.org/index.php/MacWilliams_identities">MacWilliams’ Identity</a><br>$W_{C^{\perp}}(x, y) &#x3D; \frac{1}{|C|}W_C(x+(q-1)y,x-y)$<br>当$q&#x3D;2$时:<br>$W_{C^{\perp}}(x, y) &#x3D; \frac{1}{|C|}W_C(x+y,x-y)$</p>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><p>记录一些我个人认为比较有趣的课后练习题(可能我的答案是错误的).</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/10/19/Approximation-Algorithm-9-The-Maxcut-Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/19/Approximation-Algorithm-9-The-Maxcut-Problem/" class="post-title-link" itemprop="url">Approximation Algorithm(9)-The Maxcut Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-19 13:46:06" itemprop="dateCreated datePublished" datetime="2019-10-19T13:46:06+00:00">2019-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Week 9: Maximum Cut and Semi-Definite Programming</strong></p>
<h4 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h4><p>给定边权非负的无向图$G&#x3D;(V,E)$, 将其分成两个点集$(S, G \backslash S)$, 最大化$\sum_{e \in cut(S, G \backslash S)}{w_e}$.</p>
<h4 id="Simple-2-approximation-Algorithms"><a href="#Simple-2-approximation-Algorithms" class="headerlink" title="Simple 2-approximation Algorithms"></a>Simple 2-approximation Algorithms</h4><p>假设对于每个点, 有$p$的概率选入集合$S$, 那么<br>$$<br>E(output) &#x3D; \sum_{e:&#x3D;(u, v)}{w_e Pr[u, v \text{ belong to different parts }]} &#x3D;  2p(1-p) \sum_{e:&#x3D;(u, v)}{w_e} \geq 2p(1-p) OPT<br>$$<br>显然取$p&#x3D;0.5$结果最好, 此时$E(output) \geq \frac{1}{2}OPT$. </p>
<p>偶然看到<a target="_blank" rel="noopener" href="https://gitee.com/zhenweiliu/papers/raw/master/papers%20in%20blog/maxcut.pdf">一篇资料</a>讲了如何把随机去掉，挺有意思的。在资料的3.1节部分, 过程如下：<br>给每个点分配不同的向量$\boldsymbol{x_u} \in \mathbb{F_2^k}$, 取$k &#x3D; \lceil \log_2(|V|) \rceil$即可保证存在这样的分配。<br>然后随机一个向量$\boldsymbol{r} \in \mathbb{F_2^k}$, 令$S:&#x3D; {u | \boldsymbol{r} \cdot \boldsymbol{x_u} &#x3D; 1 }$。<br>$$<br>\begin{aligned}<br>E(output) &amp;&#x3D; \sum_{e:&#x3D;(u, v)}{w_e Pr[u, v \text{ belong to different parts }]} \<br>&amp;&#x3D;  \sum_{e:&#x3D;(u, v)}{w_e Pr[\boldsymbol{r} \cdot (\boldsymbol{x_u-x_v}) \neq 0 ]} \<br>&amp;&#x3D; \sum_{e:&#x3D;(u, v)}{\frac{1}{2}w_e} \<br>&amp;\geq \frac{1}{2}OPT<br>\end{aligned}<br>$$<br>这里用到了结论$Pr[\boldsymbol{r} \cdot (\boldsymbol{x_u-x_v}) \neq 0] &#x3D; \frac{1}{2}$, 因为对于任意$\boldsymbol{w} \in \mathbb{F_2^k}$, 满足$\boldsymbol{v} \cdot \boldsymbol{w} &#x3D; 0$的向量$\boldsymbol{v}$构成了维度为$k-1$的子空间, 因此有$2^{k-1}$个满足要求的$\boldsymbol{v}$, 恰好是一半。<br>如果随机取一个$\boldsymbol{r}$, 期望是$OPT$的一半。而$\boldsymbol{r}$的取值只有$2^k &#x3D; O(|V|)$种, 可以穷举所有的$\boldsymbol{r}$然后取最优的，肯定比期望要好，这样就把算法从期望一半变成了确定的一半。</p>
<p>还有一个更加简单的贪心做法：<br>初始化集合$A&#x3D;B&#x3D;\emptyset$. 依次考虑每个点, 如果把它加入$A$集合收益大(收益指$\sum_{e \in (A,B)}{w_e}$增加的量)，就加入，否则加入$B$集合。<br>容易证明在这个过程中始终满足下面的性质:<br>$$<br>\sum_{e \in (A,B)}{w_e} \geq \sum_{e \in (A,A)}{w_e} + \sum_{e \in (B,B)}{w_e}<br>$$<br>从而得出$\sum_{e \in (A,B)}{w_e} \geq \frac{1}{2}\sum_{e}{w_e} \geq \frac{1}{2}OPT$ </p>
<h4 id="Integer-Programming-Formulation"><a href="#Integer-Programming-Formulation" class="headerlink" title="Integer Programming Formulation"></a>Integer Programming Formulation</h4><p>如果用每个点是否在集合$S$中作为变量, 目标函数就不是线性的了, 而是后面会提到的Semi-Definite Programming.<br>这里用$x_{ij} \in {0, 1}$表示点$i$和点$j$是否属于同一个集合, 那么目标函数就是$\sum_{ij}{w_{ij}x_{ij}}$。</p>
<p>给定一组${x_{ij} }$, 取$S:&#x3D;{v|x_{1v} &#x3D; 0}$为其对应的解。<br>先来看${x_{ij}}$合法的一些必要条件:</p>
<ol>
<li>考虑三个点$i, j, k$, 显然不可能$x_{ij}, x_{ik}, x_{jk}$都是1, 因此$x_{ij}+x_{ik}+x_{jk} \geq 2$.</li>
<li>考虑三个点$i, j, k$, 如果有两条边对应的变量是0, 说明这三个点属于同一个集合, 那么第三条边对应的变量也必须是0, 因此有$x_{ij} \leq x_{ik} + x_{jk}$.</li>
</ol>
<p>下面证明如果${x_{ij}}$满足这两个条件, 其对应的解$S:&#x3D;{v|x_{1v} &#x3D; 0}$是合法的:</p>
<p>需要证明$u, v$在不同集合当且仅当$x_{uv} &#x3D; 1$.</p>
<ul>
<li>如果$u, v \in S$, 那么取$V \backslash S$中的一点$w$(如果不存在，说明所有点都在$S$中，所有变量都是0), $x_{uv} + x_{uw} + x_{vw} &#x3D; x_{uv} + 1 + 1 \geq 2$,  因此$x_{uv} &#x3D; 0$. </li>
<li>如果$u,v \notin S$, 那么$x_{1u}+x_{1v}+x_{uv} &#x3D; 1 + 1 + x_{uv} \leq 2$, 即$x_{uv} &#x3D; 0$.</li>
<li>如果$u \in S, v \notin S$, 那么$x_{1v} \leq x_{1u} + x_{uv}$, 即$1 \leq 0 + x_{uv}$, 所以$x_{uv} &#x3D; 1$.</li>
</ul>
<p>因此得到Maxcut问题的一个线性规划模型：<br>$$<br>\begin{aligned}<br>\text{maximize} &amp; \sum_{i &lt; j}{w_{ij}x_{ij}}  \<br>\text{subject to} \ &amp;x_{ij} + x_{ik} + x_{jk} &amp;\leq 2 \quad &amp;\forall i,j,k \in V \<br>&amp;x_{ij} - x_{ik} - x_{jk} &amp;\leq 0 \quad &amp;\forall i,j,k \in V \<br>&amp;x_{ij} \in {0, 1} \quad &amp; &amp;\forall i, j \in V<br>\end{aligned}<br>$$</p>
<h4 id="Integrality-Gap-of-LP-Model"><a href="#Integrality-Gap-of-LP-Model" class="headerlink" title="Integrality Gap of LP Model"></a>Integrality Gap of LP Model</h4><p>上面提出的线性规划模型虽然很有道理，然而下面要证明一个悲惨的事实: 基于上面线性规划的近似算法不可能做到比2更好的近似比。<br>integrality gap指的是线性规划的实数最优解和整数最优解的比值。下面假设解决的是一个求最大值的问题。<br>如果有常数$\beta$, 对问题的任意instance $I$,恒有 $\frac{LP(I)}{IP(I)} \geq \beta$, 那么称$\beta$的最大值为这个问题的integrality gap。<br>在借助线性规划模型设计近似算法并证明近似度的时候，我们需要证明$\frac{IP(I)}{output} \leq \alpha$。但是谁也不知道$IP(I)$是多少，我们只能用$\frac{LP(I)}{output}$ 来bound $\frac{IP(I)}{output}$。 而$\frac{LP(I)}{output} \geq \frac{LP(I)}{IP(I)} \geq \beta$, 因此我们不可能设计近似算法做到比$\beta$更好的近似度。<br>对于maxcut问题, 可以证明integrality gap是2. </p>
<p>coursera上的证明非常不完整，我找了很多paper都指向了这篇：<br><em>Svatopluk Poljak. Polyhedral and eigenvalue approximations of the max-cut problem. Sets, Graphs and Numbers, Colloquia Mathematica Societatis Janos Bolyai, 60:569–581, 1992</em>.<br>遗憾的是这好像是一本书，没法免费下载。</p>
<p>coursera上提到了大致思想是: 考虑图$G(n, p)$, 每条边有$p$的概率在这个图内。边权都是1.<br>定义事件A: 图$G$包含于某个长度不大于$k$的环中的边数不超过$|V|^{0.5}$.<br>定义事件B: 把图$G$包含于某个长度不大于$k$的环中的边全删掉得到的图$G’$满足$maxcut(G’) \leq (\frac{1}{2}+o(1)) |E|$<br>根据<a target="_blank" rel="noopener" href="https://gitee.com/zhenweiliu/papers/raw/master/papers%20in%20blog/poljak1994.pdf">paper1</a>如果一个图G不存在长度小于$k$($k$比较小)的环, 那么$LP(G)$非常接近边的数量。从而推出$LP(G’) \geq (1-o(1))|E|$.<br>paper1中把我们的LP转化为另一个LP, 并说明两个LP的最优解是一样的，证明在<a target="_blank" rel="noopener" href="https://gitee.com/zhenweiliu/papers/raw/master/papers%20in%20blog/cut-lp.pdf">paper2</a>中, 我花了大概1h看了下，感觉证明思路挺新奇的。<br>最后通过证明$Pr[A \cap B] \gt 0$, 说明存在某个图$G’$, $\frac{LP(G’)}{maxcut(G’)} &#x3D; 2-o(1)$.</p>
<h4 id="Semi-Definite-Programming"><a href="#Semi-Definite-Programming" class="headerlink" title="Semi-Definite Programming"></a>Semi-Definite Programming</h4><p>其实刚拿到maxcut这个问题，更自然地会想到用每个点是否在集合$S$中作为变量来写出一个规划方程:<br>$$<br>\begin{aligned}<br>\text{maximize} \quad &amp;\frac{1}{2} \sum_{i &lt; j}{w_{ij}(1-x_ix_j)} \<br>\text{subject to} \quad &amp;x_i \in {-1, 1} \quad \forall i \in V<br>\end{aligned}<br>$$<br>同样地, 我们希望把变量是整数的限制去掉, 做一个relaxation。<br>注意到$x_i^2 &#x3D; 1$, 开一下脑洞, 把$x_i$看做是一个$d$维向量, 之后记为$\boldsymbol{v_i} \in \mathbb{R^d}$, 满足$|\boldsymbol{v_i}|_2 &#x3D; 1$.</p>
<p>我们得到一个向量规划:<br>$$<br>\begin{aligned}<br>\text{maximize} \quad &amp;\frac{1}{2} \sum_{i &lt; j} w_{ij}(1-\boldsymbol{v_i}\cdot \boldsymbol{v_j}) \<br>\text{subject to} \quad &amp;|\boldsymbol{v_i}|^2&#x3D;1 \quad \forall i \in V<br>\end{aligned}<br>$$<br>观察到上面的规划式子只和向量$\boldsymbol{v_i}\cdot \boldsymbol{v_j}$有关, 对应一个对称的实矩阵$A$, 满足$A_{ij}:&#x3D; \boldsymbol{v_i}\cdot \boldsymbol{v_j}$。可以证明这个矩阵是半正定的(positive semi-definite):<br>证明: $V:&#x3D;(\boldsymbol{v_1}, \boldsymbol{v_2}, \cdots, \boldsymbol{v_n}) \rightarrow A&#x3D;V^TV \rightarrow \forall \boldsymbol{x}\in \mathbb{R^n}, \boldsymbol{x}^TA\boldsymbol{x} &#x3D; (Vx)^T(Vx) &#x3D; |Vx|_2 \geq 0$.<br>反过来, 如果取向量$\boldsymbol{v_i}$的维度$d &#x3D; n$, 那么任意一个半正定的矩阵也对应了一组$\boldsymbol{v_i}$, 因为任意半正定矩阵$A$可以分解为$U^TU$的形式, $U$是特征向量构成的矩阵, 让$\boldsymbol{v_i}$对应$U$的每一列即可。</p>
<p>因此上面的向量规划的可行解和下面的半正定规划的可行解对应：<br>$$<br>\begin{aligned}<br>\text{maximize} \quad &amp;\frac{1}{2} \sum_{i &lt; j}{w_{ij}(1-A_{ij})} \<br>\text{subject to} \quad &amp;A_{ii}&#x3D;1 \quad \forall 1\leq i \leq n \<br>&amp;A \text{ is positive semi-definite}<br>\end{aligned}<br>$$<br>这个规划是个凸优化, 用椭球法可以在多项式时间内获得任意接近最优解的解(最优解可能是无理数, 只能无限逼近)。<br>之后, 我们假定已经求出了最优解对应的向量$\boldsymbol{v_1}, \boldsymbol{v_2}, \cdots, \boldsymbol{v_n}$, 定义$\theta_{ij}$为$\boldsymbol{v_i}, \boldsymbol{v_j}$之间的夹角.<br>显然<br>$$<br>OPT \leq \frac{1}{2} \sum_{i &lt; j}{w_{ij}(1-\boldsymbol{v_i}\cdot \boldsymbol{v_j})} &#x3D; \frac{1}{2} \sum_{i &lt; j}{w_{ij}(1-\cos\theta_{ij})}<br>$$</p>
<p>考虑rounding: 随机取一个单位向量$\boldsymbol{r}$, $|\boldsymbol{r}|<em>2 &#x3D; 1$, 如果$\boldsymbol{v_i} \cdot \boldsymbol{r} \gt 0$, $x_i :&#x3D; 1$, 否则$x_i :&#x3D; 0$。考虑解的期望值:<br>$$<br>E[output] &#x3D;  \sum</em>{i &lt; j}{w_{ij}E[\frac{1-\boldsymbol{v_i}\cdot \boldsymbol{v_j}}{2}]} &#x3D; \sum_{i &lt; j}{w_{ij}Pr[\boldsymbol{v_i} \cdot \boldsymbol{r} \neq \boldsymbol{v_j} \cdot \boldsymbol{r}]}<br>$$</p>
<p>关键是分析$Pr[\boldsymbol{v_i} \cdot \boldsymbol{r} \neq \boldsymbol{v_j} \cdot \boldsymbol{r}]$.<br>设过原点并与$\boldsymbol{v_i}$垂直的平面$F_1$, 过原点并与$\boldsymbol{v_j}$垂直的平面$F_2$, $\boldsymbol{v_i} \cdot \boldsymbol{r} \neq \boldsymbol{v_j} \cdot \boldsymbol{r}$当且仅当$\boldsymbol{r}$落在$F_1, F_2$的夹角中间(小于等于90度的角), 因此概率就是$\frac{\theta_{ij}}{\pi}$. (从三维几何的角度很容易想明白, 但是更高维感觉就不怎么显然了, 我尝试寻找一个代数的证明, 然而网上的资料包括算法的原论文都是从几何的角度一笔带过, 暂时留个坑吧)<br>再利用一个lemma: $\frac{\theta}{\pi} \geq 0.878\frac{1-\cos\theta_{ij}}{2}$<br>$$<br>E[output] &#x3D; \sum_{i &lt; j}{w_{ij}\frac{\theta_{ij}}{\pi}} \geq 0.878\sum_{i &lt; j}{w_{ij}\frac{1-\cos\theta_{ij}}{2}}<br>$$<br>因此$\frac{E[output]}{OPT} \geq 0.878$.<br>lemma的证明只需要求$\frac{\pi(1-\cos \theta)}{2\theta}$的最大值就好了。</p>
<p>可以证明在<strong>Unique Games Conjecture</strong>成立的情况下, 不可能做到比0.878更好。 </p>
<p>最后还有一个有趣的小问题: 如何随机一个向量$\boldsymbol{r}$?<br>只要令$r_i \sim N(0, 1)$, 即每一维的取值独立地服从标准正态分布, 最后做一次正规化让它的模变成1即可。<br>证明:<br>$$p(x_1, \cdots, x_n) &#x3D; \int_0^{\infty}{\prod_{i&#x3D;1}^n \frac{ e^{-\frac{(tx_i)^2}{2}} }{\sqrt{2 \pi}}dt} &#x3D;<br>\int_{0}^{\infty}{\frac{e^{-\frac{1}{2}t^2\sum_{i&#x3D;1}^n{x_i^2}}}{(2\pi)^{n&#x2F;2}}dt} &#x3D; \int_0^{\infty}{\frac{e^{-\frac{1}{2}t^2}}{(2\pi)^{n&#x2F;2}}dt}<br>$$<br>和具体$x_i$的取值无关。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/09/27/Approximation-Algorithm-8-The-Facility-Location-Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/27/Approximation-Algorithm-8-The-Facility-Location-Problem/" class="post-title-link" itemprop="url">Approximation Algorithm(8)-The Facility Location Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-27 16:50:43" itemprop="dateCreated datePublished" datetime="2019-09-27T16:50:43+00:00">2019-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Week 8: The Facility Location Problem</strong></p>
<h4 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h4><p>小区里要建某种公共设施, 可以建造设施的位置集合为$\mathcal{F}$, 在第$i$个位置建造设施的花费是$f_i$. 设顾客集合为$\mathcal{C}$, $c_{ij}$表示顾客$j$与设施$i$之间的距离, 且约定这个距离满足三角形不等式(即$c_{ij}$就是设施$i$和顾客$j$的最短距离)。显然，每个顾客会选择离自己最近的设施。作为政府，一个目标是建造设施的代价尽可能少，另一个目标是不能让顾客离设施太远。定义总代价为建造设施的代价加上每个顾客到离自己最近的建好的设施的距离之和, 设计策略使得总代价尽可能小。</p>
<h4 id="Linear-Programming-Relaxation"><a href="#Linear-Programming-Relaxation" class="headerlink" title="Linear Programming Relaxation"></a>Linear Programming Relaxation</h4><p>变量$x_{ij}$表示顾客$j$最终选择设施$i$, $y_i$表示是否建造设施$i$，容易设计下面的线性规划模型及其对偶(对偶的含义有点不太好解释).</p>
<table>
<thead>
<tr>
<th align="center">Primal</th>
<th align="center">Dual</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$$ \begin{aligned} &amp;\text{minimize } \quad &amp;\sum_{i \in \mathcal{F}}\sum_{j \in \mathcal{C}}{c_{ij}x_{ij}} + &amp;\sum_{i \in \mathcal{F}}{f_iy_i} \ &amp;\text{subject to } &amp;\sum_{i \in \mathcal{F}}{x_{ij}} \geq 1, \ \  &amp;\forall j \in \mathcal{C} \ &amp; &amp;x_{ij}-y_i \geq 0, &amp;\forall i \in \mathcal{F},\ \forall j \in \mathcal{C} \ &amp; &amp;x_{ij} \geq 0, &amp;\forall i \in \mathcal{F},\ \forall j \in \mathcal{C} \ &amp; &amp;y_i \geq 0,  &amp;\forall i \in \mathcal{F} \end{aligned} $$</td>
<td align="center">$$ \begin{aligned} &amp;\text{maximize} \quad &amp;\sum_{j \in \mathcal{C}}{\alpha_j} \quad \quad &amp; \ &amp;\text{subject to } &amp;\sum_{j \in \mathcal{C}}{\beta_{ij}} \leq f_i, \ \  &amp;\forall j \in \mathcal{C} \ &amp; &amp;\alpha_j-\beta_{ij} \leq c_{ij}, \ \ &amp;\forall i \in \mathcal{F},\ \forall j \in \mathcal{C} \ &amp; &amp;\beta_{ij} \geq 0, &amp;\forall i \in \mathcal{F},\ \forall j \in \mathcal{C} \ &amp; &amp;\alpha_i \geq 0,  &amp;\forall j \in \mathcal{C} \end{aligned} $$</td>
</tr>
</tbody></table>
<h4 id="An-4-approximation-Algorithm"><a href="#An-4-approximation-Algorithm" class="headerlink" title="An 4-approximation Algorithm"></a>An 4-approximation Algorithm</h4><p>这个算法颠覆了我对原始对偶算法的认知，因为之前学到的原始对偶算法都是让对偶变量不断增大，直到某个条件恰好被bound住，然后令其对应的原始变量增大，相对来说比较系统化。而本算法是先分别求解Primal和Dual，然后根据实数最优解解贪心的构造出一个解。</p>
<h5 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h5><ol>
<li>求出Primal和Dual的最优解,${x^{*}, y^{*}, \alpha^{*}, \beta^{*} }$.</li>
<li>考虑一个新图$G’$为原图$G$去掉$x^{*}<em>{ij} &#x3D; 0$的边, 重复以下过程，直到所有顾客都有设施可去.<br> 2.1. 执行第$k$次过程, 从还没有被满足的顾客中，选取一个对应的$\alpha^{*}$最小的, 设标号是$j_k$。<br> 2.2. 建造一个设施$i_k$, 满足$f</em>{i_k} &#x3D; \min_{i: x_{ij_k} \gt 0} {f_i}$.<br> 2.3. 令顾客$j_k$和所有和顾客$j_k$距离不超过2的未被满足的顾客，都到设施$i_k$去。</li>
</ol>
<h5 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h5><p>考虑被分给设施$i_k$的某个顾客j, 必然有$dist(i_k, j) &#x3D; 1, 3$.</p>
<ul>
<li>若$dist(i_k, j) &#x3D; 3$, 存在一个中间设施$t$, 满足存在路径$j \rightarrow t \rightarrow j_k \rightarrow i_k$, 根据三角形不等式性质$c_{i_kj} \leq c_{tj} + c_{tj_k} + c_{i_kj_k}$。 根据线性规划的<strong>complementary slackness condition</strong>, $x^{*}<em>{ij} \gt 0$意味着$\alpha^{*}<em>j - \beta^{*}</em>{ij} &#x3D; c</em>{ij}$, 所以$c_{ij} \leq \alpha_j^{*}$,，于是有$c_{i_kj} &#x3D; c_{tj} + c_{tj_k} + c_{i_kj_k} \leq \alpha^{*}<em>j + 2\alpha^{*}</em>{j_k} \leq 3\alpha^{*}_j$, 最后一个不等号是因为算法每次选的$j_k$是$\alpha^{*}$最小的。</li>
<li>若$dist(i_k, j) &#x3D; 1$, $c_{i_kj} \leq \alpha^{*}_j$.</li>
</ul>
<p>综上，设顾客$j$被算法分配到了设施$\sigma(j)$, 那么$\sum_j{ c_{\sigma(j) j} } \leq 3 \sum_j{\alpha^{*}_j} \leq 3OPT$. </p>
<p>另一部分费用是建造设施的费用。<br>$$f_{i_k} \leq \sum_{i \in \mathcal{F}}{x_{ij_k}^{<em>}f_{i_k}} &#x3D; \sum_{i: x^{</em>}<em>{ij_k} \gt 0}{x^{*}</em>{ij_k}f_{i_k}} \leq \sum_{i: x^{<em>}_{ij_k} \gt 0}{x^{</em>}<em>{ij_k}f</em>{i}} \leq \sum_{i: x^{<em>}_{ij_k} \gt 0}{y^{</em>}<em>if</em>{i}}$$<br>第一个不等号利用了Primal的第一个约束，第二个不等号用了算法2.2步的最小性，最后一个不等号用了Primal的第二个约束。<br>因为算法2.3步把距离$j_k$小于等于2的顾客都满足了，所以$\sum_{i: x^{*}<em>{ij</em>{p}} \gt 0}{y^{*}<em>if</em>{i}}$和$\sum_{i: x^{*}<em>{ij</em>{q}} \gt 0}{y^{*}<em>if</em>{i}}$是没有公共部分的。<br>综上$\sum_k f_{i_k} \leq \sum_{i \in \mathcal{F}}{y^{*}_i f_i} \leq OPT$.</p>
<p>两部分费用结合一下得出算法近似比是4.</p>
<h4 id="An-3-approximation-Algorithm"><a href="#An-3-approximation-Algorithm" class="headerlink" title="An 3-approximation Algorithm"></a>An 3-approximation Algorithm</h4><p>这一部分感觉coursera上讲的不是很好, 不如直接读原作者的<a target="_blank" rel="noopener" href="https://gitee.com/zhenweiliu/papers/raw/master/papers%20in%20blog/facilitylocation.pdf">paper</a><br>这个算法本质就是原始对偶算法, 和之前的问题不同的是, 对偶问题中的约数条件$\alpha_j-\beta_{ij} \leq c_{ij}$, 对偶变量的系数有正有负，因此不能简单地像之前一样同时增加对偶变量。</p>
<h5 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h5><p><strong>Phase 1:</strong><br>初始$\alpha_j &#x3D; 0, \beta_{ij} &#x3D; 0$, 所以$\alpha_j$都是<strong>free</strong>的, 所有$\beta_{ij}$都是<strong>frozen</strong>的。所有的顾客都是<strong>unconnected</strong>.<br>同时以单位速度增加所有free的变量, 直到所有变量都是frozen.<br>一开始只会增加$\alpha_j$, 当对于某个$i$, $\alpha_j &#x3D; c_{ij}$的时候, 为了保持$\alpha_j-\beta_{ij} \leq c_{ij}$仍然被满足, 把$\beta_{ij}$设成free, 即让它和$\alpha_j$一起以单位速度增加。 另一方面，随着$\beta_{ij}$的增加, 某些$\sum_{j \in \mathcal{C}}{\beta_{ij}} \leq f_i$等号会成立, 这时$\beta_{ij}$就不能再接着增加了, 将其置为frozen, 同时将设施$i$设为<strong>temporarily open</strong>. 显然这个时候和它一起增加的$\alpha_j$也不可以再增加了, 同样置为frozen。<br>为了之后方便分析, 称满足$\alpha_j \geq c_{ij}$的边是<strong>tight</strong>的, 称$\beta_{ij} \gt 0$的边是<strong>special</strong>的(根据算法过程, special的边一定是tight的)。在算法执行过程中, 一旦某个unconnected的顾客$j$的某条边变成了tight, 且这条边连着的设施$i$是temporarily open的, 那么把这个顾客置为<strong>connected</strong>, 并称设施$i$是顾客$j$的<strong>connecting witness</strong>。显然算法结束的时候每个顾客都会变成connected, 并且有唯一的connecting witness。<br>如果同一时间发生了多个时间, temporarily open事件优先于connected事件。如果某个顾客的多条边同时变成tight, 且连出去的设施都是temporarily open的，那么任选一个作为connecting witness。</p>
<p><strong>Phase 2:</strong><br>定义新图$G’$, 顶点是所有temporarily open的设施, 两个设施有边当且仅当原图中两个设施可以通过两条special的边到达。 $G’$一个极大独立集$I$, 确定这些设施是最终<strong>open</strong>的设施。对于顾客$j$, 如果有一条special的边连接他和某个open的设施, 那么顾客$j$就去这个设施($\sigma(j):&#x3D;i$), 记为第一类顾客。否则, 假设顾客$j$的connecting witness是设施$i$, 如果$i$是open的, 那么令$\sigma(j):&#x3D;i$, 记为第二类顾客。如果$i$不是open的，那么$G’$中必定有$i$的邻居$i’ \in I$, 令$\sigma(j):&#x3D; i’$, 记为第三类顾客.<br>三类顾客的集合分别记为$I_1, I_2, I_3$.</p>
<h5 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h5><p><strong>Key Observation</strong>：</p>
<ol>
<li>如果边$ &lt; i, j &gt; $ 是tight的, 那么必然有$\alpha_j - \beta_{ij} &#x3D; c_{ij}$.</li>
<li>如果边$ &lt; i, j &gt; $ 不是tight的, 那么必然有$\beta_{ij} &#x3D; 0$.</li>
<li>如果一个设施$i$是open的, $f_i &#x3D; \sum_{j \in \mathcal{C}}{\beta_{ij}}$.</li>
</ol>
<p>建造设施的费用:<br>$$<br>\sum_{i \in I}{f_i} &#x3D; \sum_{i \in I}{\sum_{j \in \mathcal{C}}{\beta_{ij}}} &#x3D; \sum_{i \in I}{\sum_{ &lt;i, j&gt; \text{ is special }}{\beta_{ij}}}<br>$$</p>
<p><strong>第一类顾客的费用</strong>：<br>$$<br>\sum_{j \in \mathcal{C}<em>1}{c</em>{\sigma(j)j}} &#x3D; \sum_{i \in I}{\sum_{ &lt;i, j&gt; \text{ is special }}{c_{ij}}}<br>$$</p>
<p><strong>因此第一类顾客的费用和建造设施的费用之和是</strong>:<br>$$<br>\sum_{i \in I}{\sum_{ &lt;i, j&gt; \text{ is special }}{\beta_{ij} + c_{ij}}} &#x3D; \sum_{i \in I}{\sum_{ &lt;i, j&gt; \text{ is special }}{\alpha_j}} &#x3D; \sum_{j \in \mathcal{C}_1}{\alpha_j}<br>$$</p>
<p><strong>第二类顾客的费用</strong>:<br>$$<br>\sum_{j \in \mathcal{C}<em>2}{c</em>{\sigma(j)j}} &#x3D; \sum_{j \in \mathcal{C}_2}{\alpha_j}<br>$$<br>因为根据定义, 边$ &lt;\sigma(j), j&gt; $是tight的, 并且不是special的。</p>
<p><strong>第三类顾客的费用</strong>:<br>考虑顾客$j \in \mathcal{C}<em>3$, 他的connecting witness是$i$, $\sigma(j) &#x3D; i$, $i$和$i’$在$G’$中是邻居, 因此还存在一个顾客边$j’$, $ &lt; i, j’&gt;, &lt; i’, j’&gt;$都是special的. 注意边$&lt; i’, j&gt;$是tight但不是special的。如下图所示：<br> <img src="/2019/09/27/Approximation-Algorithm-8-The-Facility-Location-Problem/1.png" class=""><br>根据三角形不等式得到$c</em>{ij} \leq c_{i’j} + c_{i’j’} + c_{ij’} \leq \alpha_j + 2\alpha_{j’}$。<br>接下来一步是我个人感觉整个证明最难理解的一步：因为$i’$是$j$的connecting witness, 所以当边$&lt; i’, j&gt;$变成tight的瞬间, $i’$已经是temporarily open了, 也就是说$\sum_{j \in \mathcal{C}}{\beta_{i’j}} &#x3D; f_{i’}$, 这时$\beta_{i’j’}$和$\alpha_{j’}$都会变成frozen, 且$\alpha_j &#x3D; \alpha_{j’}$. 而之后$\alpha_{j’}$再也不会增加, $\alpha_j$还可能增加。因此有$\alpha_{j’} \leq \alpha_{j}$.<br>所以$c_{ij} \leq c_{i’j} + c_{i’j’} + c_{ij’} \leq \alpha_j + 2\alpha_{j’} \leq 3 \alpha_j$。</p>
<p>综合四种费用, 容易得到$cost \leq 3\sum_{j \in \mathcal{C}}{\alpha_j} \leq 3OPT$.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/" class="post-title-link" itemprop="url">Approximation Algorithm(7)-The Steiner Forest Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-05 15:25:57" itemprop="dateCreated datePublished" datetime="2019-09-05T15:25:57+00:00">2019-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Week 7: The Steiner Forest Problem</strong></p>
<h4 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h4><p>给定联通无向图$(V, E)$和若干个terminals的集合$S_i &#x3D; {t_{i,1}, t_{i,2}, \cdots, t_{i, k_i} }$, 要求选出边权和最小的边，使得任意$S_i$中的点联通。</p>
<h4 id="Case-Study-Steiner-Tree"><a href="#Case-Study-Steiner-Tree" class="headerlink" title="Case Study: Steiner Tree"></a>Case Study: Steiner Tree</h4><p>考虑只有一个集合$S &#x3D; {t_1, t_2 \cdots t_k}$, 要使得集合内部的点联通。</p>
<p>这个问题在ACM&#x2F;ICPC竞赛见过,一般用动态规划来解决。</p>
<p>最终答案一定是一棵生成树，因此可以用动态规划的思想一步步构造出这棵树。</p>
<p>$dp_{u,s}$表示以$u$为根，并且能使集合$s$中的点都联通的生成树的最小边权和，答案就是$\min_u dp_{u, S}$。实际coding的时候用$k$个bit来表示一个集合。</p>
<p>分下面两种情况转移：</p>
<ol>
<li>$u$下面至少有2棵子树，$dp_{u,s} &#x3D; \min_{s’}{(dp_{u,s’} + dp_{u,s\backslash s’})}$, 相当于枚举其中一棵子树的联通性$s’$来转移。</li>
<li>$u$下面只有1棵子树，那么需要枚举$u$的儿子$v$, $dp_{u,s} &#x3D; \min_v{(dp_{v, s} + w(u,v))}$, 这个过程本质上和最短路的松弛操作一样，可以用dijkstra算法来实现。</li>
</ol>
<p><strong>近似算法设计</strong></p>
<p>如果$S&#x3D;V$, 那么最优解就是最小生成树，所以我们可以从最小生成树的角度出发来设计近似算法。</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>构造新图$(V’, E’)$, 其中$V’ &#x3D; S$, $E’ &#x3D; {(t_i, t_j, t_i和t_j之间最短路长度)}$。</li>
<li>求出新图的MST。</li>
<li>输出新图MST对应的原图的边。</li>
</ol>
<p><strong>Analysis</strong></p>
<p>正确性显然，只需要分析近似度。</p>
<p>考虑最优解一定是一棵树，如果把这棵树的每条边复制一份，构成的新图是一个欧拉图(每个点的度都是偶数)。考虑这个新图的一条欧拉回路$P:&#x3D;(t_{i_1}, t_{i_2}, \cdots, t_{i_m})$, 点$t_{i,j}$与点$t_{i,j+1}$之间的路，大于等于它们在 $V’$中对应的边长。$P$对应到$V’$中相当于选了一些边使得$V’$联通，因此$2OPT &#x3D; length(P) \geq MST(V’)$，也就是说近似比是2.</p>
<h4 id="LP-Relaxation-for-Steiner-Forest"><a href="#LP-Relaxation-for-Steiner-Forest" class="headerlink" title="LP Relaxation for Steiner Forest"></a>LP Relaxation for Steiner Forest</h4><p>定义$\mathcal{S} :&#x3D; {S: \exists i \exists u,v \in S_i: |S\cap{u,v}| &#x3D; 1}$, 也就是那些能把某两个同一个集合内的terminals分成两边的cut。$\delta(S) &#x3D; {e: |e\cap S| &#x3D; 1}$ 即跨过$S$和$V\backslash S$的边。</p>
<p>显然，经过这些cut的那些边至少需要选一条。反过来，如果对于任意cut，穿过cut的边至少有一条被选中，那么一定合法解，只要验证$\forall i, \forall u,v\in S_i$, $u, v$之间有路。可以按照下面的算法来找到$u,v$之间的路:</p>
<ol>
<li>$A:&#x3D;{u}$, $F:&#x3D;\emptyset$.</li>
<li>重复过程： 如果$v \notin A$, 那么$A \in \mathcal{S}$, 一定存在一条边$e&#x3D;(x,y)$, 满足$x \in A, y \notin A$, 令 $A:&#x3D; A \cup{y}$。</li>
</ol>
<p>上面的过程一定会在有限步结束，且$A$一直是一个联通块。 最终$u,v \in A$ 联通。</p>
<p>根据上面的思路，容易得到线性规划的式子:<br>$$<br>\begin{aligned}<br>&amp;\min w_ex_e \<br>&amp;\forall S\in \mathcal{S}, \sum_{e\in\delta(S)}{x_e} \geq 1 \<br>&amp;\forall e \in E, x_e \geq 0<br>\end{aligned}<br>$$<br>然而约数个数是指数级别的，我们不可能去解这个线性规划。</p>
<h4 id="Primal-Dual-Algorithm"><a href="#Primal-Dual-Algorithm" class="headerlink" title="Primal-Dual Algorithm"></a>Primal-Dual Algorithm</h4><p><a target="_blank" rel="noopener" href="https://webdocs.cs.ualberta.ca/~mreza/courses/Approx15/lecture9.pdf">参考资料</a></p>
<p><strong>Dual LP</strong>:<br>$$<br>\begin{aligned}<br>&amp;\max y_S \<br>&amp;\forall e \in E, \sum_{S: e \in \delta(S)}y_S \leq w_e \<br>&amp;\forall S \in \mathcal{S}, y_S \geq 0<br>\end{aligned}<br>$$<br>类似上周顶点覆盖问题的primal-dual算法， 我们从初始解$y &#x3D; {0 \cdots 0}$开始慢慢增加$y_S$, 并把达到约束条件$\sum_{S: e \in \delta(S)}y_S \leq w_e$的边加入答案。</p>
<p>但是这样有一个问题，对偶的变量$y$太多了，不可能像顶点覆盖问题一样同时增加$y$的值, 需要设计更加有效的算法。</p>
<p>定义一个集合$S$是active的当且仅当$\sum_{e\in\delta(S)}{x_e} \geq 1$这个条件还未被满足，并且$S$是minimal的, 即不存在一个$S$的子集$S’$仍未满足Primal LP的条件。</p>
<p>为了解决变量$y_S$过多的问题，我们只增加active的$S$对应的变量$y_S$. 一开始active的集合只有那些terminals所在的集合${t_{i,j}}$。</p>
<img src="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/1.png" class="">

<p>注意算法第6步还有一个去掉不必要的边的过程，这一步对近似度至关重要，之后会分析。</p>
<p><strong>Lemma:</strong> 集合$S$是active的当且仅当$S$是$F$的诱导子图的一个联通块。</p>
<p>证明： </p>
<ul>
<li>如果$S$包含了诱导子图中的某个联通块$T$的一部分。那么存在某条边$e &#x3D;(u,v) \in F, u\in S, v \in T \backslash S$,  因此$\sum_{e\in\delta(S)}{x_e} \geq 1$, $S$不可能是active。</li>
<li>排除上面的情况后，$S$只可能由$F$诱导子图的一个或者多个联通块构成。如果由多个联通块构成，取其中一个联通块$T$, $T \subset S$并且$T$也不满足LP的条件，因此$S$不是minimal。</li>
</ul>
<p>利用该引理很容易维护所有的active set。</p>
<h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><h5 id="Runtime-and-Correctness"><a href="#Runtime-and-Correctness" class="headerlink" title="Runtime and  Correctness"></a>Runtime and  Correctness</h5><p>每轮在active set的点都会增加一个，因此算法经过最多$|V|-1$轮就会结束。算法结束的时候，图中不存在active set，根据active set的定义当前解就是合法解。</p>
<h5 id="Approximation-Ratio"><a href="#Approximation-Ratio" class="headerlink" title="Approximation Ratio"></a>Approximation Ratio</h5><p>首先下面的例子解释了为什么需要算法的第6步：</p>
<img src="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/2.png" class="">

<p>算法会把所有边加入到答案，而实际上只需要权值为18的那条边就够了。</p>
<p>类似上面的方法，可以构造下面的边$1-w$, 右边一条边$w+1$, $OPT &#x3D; w+1, output &#x3D; \frac{w*(w+1)}{2}$, 近似比是$\frac{w}{2}$。</p>
<p>$$<br>\begin{aligned}<br>value(output) &amp;&#x3D; \sum_{e\in F’}{w_e} \<br>&amp;&#x3D; \sum_{e\in F’}\sum_{S: e\in \delta(S)}{y_S} \<br>&amp;&#x3D; \sum_{S\in \mathcal{S}}{y_S}|\delta(S) \cap F’| \<br>&amp;&#x3D; \int_{0}^{\infty}{\sum_{S \text{ is active beteen time}(t, t+dt) } |\delta(S) \cap F’|dt}<br>\end{aligned}<br>$$</p>
<p>关键是如果处理$|\delta(S) \cap F’|$.</p>
<p>因为算法的第6步去掉了无用的边，$F’$的导出子图$G’$(显然是森林)所有叶子一定都是terminals。</p>
<p>考虑在时刻$t$, 如果把$G’$中每个active set缩成一个点，构成新的森林$G’’$, $|\delta(S) \cap F’|$就是$S$在$G’’$中对应的节点的度。</p>
<p><strong>Lemma</strong>: 给定一棵树和包含树的所有叶子的某个顶点集合$X$, 那么有$\frac{\sum_{x \in X}{deg(x)}}{|X|} \leq 2$，即平均度数不超过2.</p>
<p>证明可以用归纳法。$|X| &#x3D; |V|$的时候成立。</p>
<p>假设$|X| &#x3D; k$的时候成立。考虑任意包含所有叶子的集合$X’, |X’|&#x3D; k-1$. </p>
<p>考虑任意internal node $u$,  $\sum_{x \in X’\cup{u}}{deg(x)} &#x3D; deg(u)+\sum_{x \in X’}{deg(x)}\leq 2k$.</p>
<p>因为$deg(u) \geq 2$, $\sum_{x \in X’}{deg(x)} \leq 2k-deg(u)\leq2k-2$</p>
<p>其实也可以从另一个角度来想: 除了叶子之外每个点的度数都至少是2，要使得平均度数超过2，那么极限情况是把所有点都取过来，结果也没超过2. </p>
<p>显然引理可以扩展到森林的情况。</p>
<p>根据引理<br>$$<br>\sum_{S \text{ is active beteen time}(t, t+dt) }{ |\delta(S) \cap F’| \leq 2\times # (\text{active sets}) }<br>$$</p>
<p>因此<br>$$<br>\begin{aligned}<br>value(output) &amp;&#x3D; \int_{0}^{\infty}{\sum_{S \text{ is active beteen time}(t, t+dt) } |\delta(S) \cap F’|dt} \<br>&amp;\leq \int_{0}^{\infty}{2 \times #(\text{active sets})dt} \<br>&amp;&#x3D; 2 \sum_{S \in \mathcal{S}}y_S \<br>&amp;\leq 2OPT<br>\end{aligned}<br>$$<br>近似比是2.</p>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><h5 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h5><p>一个从线性规划角度做无向图单源最短路的题，最终得到的primal-dual算法本质上和Dijkstra算法异曲同工，可以证明近似比是1，也就是最优算法，挺有意思的。</p>
<img src="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/3.png" class="">

<img src="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/4.png" class="">

<img src="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/5.png" class="">

<img src="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/6.png" class="">

<img src="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/7.png" class="">

<img src="/2019/09/05/Approximation-Algorithm-7-The-Steiner-Forest-Problem/8.png" class="">

<h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h5><p><strong>Question 1</strong><br>$$<br>\begin{array}<br>&amp; \max \sum_{S \in \mathcal{S}}y_S \<br>\forall e \in E, \quad \sum_{S:e\in	\delta(S)}y_S \leq w_e\<br>\forall S \in \mathcal{S}, \quad y_S \geq 0<br>\end{array}<br>$$</p>
<p><strong>Question 2</strong></p>
<p>Since when some $y_C$ is increased, a new edge which is in $\delta(C)$ is added into $F$, by the definition of $C$, $C$ will never be chosen in the future loops since it’s expanded in each loop. Thus a given dual variable be increased at most once.</p>
<p><strong>Question 3</strong></p>
<p>Initially, $C &#x3D; {s}$.</p>
<p>Then after each iteration, some edge $e &#x3D; (u, v)\in \delta(C)$ is added into $F$,  without loss of generality, assume $u \in C, v \in V \backslash C$.  Then by the definition of $C$, in the next iteration we will have $C’ &#x3D; C \cup{v}$, which means the cardinality of $C$ is increased by 1 after each iteration.  Thus the algorithm terminates in no more then $|V|-1$ iterations.</p>
<p><strong>Lemma 1</strong>. At any step of the algorithm, the set $F$ is a tree that contains $S$..</p>
<p><strong>Proof of Lemma 1</strong>:</p>
<p>Denote the set $C$ after the $i^{th}$ iteration as $C_i$, the set $F$  after the $i^{th}$ iteration as $F_i$.</p>
<p>When $i&#x3D;1$, some edge $e_1 &#x3D; (s, v)$ is added into $F$, $F_1 &#x3D; {(s, v)}$ is certainly a tree.</p>
<p>Assume the lemma holds for $i-1$. </p>
<p>Suppose $e_i &#x3D; (u, v) \in \delta(C_{i-1})$ is added into $F_{i-1}$ in the $i$ the iteration($F_i :&#x3D; F_{i-1}\cup{(u, v)}$) and without loss of generality we can assume $u \in C_{i-1}, v \in V \backslash C_{i-1}$and $C_{i} &#x3D; C_{i-1} \cup {v}$. </p>
<p>Since $ F_{i-1}$ is a tree, and $u$ is a tree node of $F_{i-1}$ but $v$ is not, $ F_i $ must also be a tree.</p>
<p><strong>Question 4</strong></p>
<p>First we argue that $val(P^*)$ is the optimal solution of the integer version of the primal LP(i.e. ILP) .</p>
<p>As weights of edges are positive, $P^{*}$must be a simple path.  Then it’s easy to check that $x_e &#x3D; 1, \forall e\in P^{*}$ is a feasible solution of $ILP_{primal}$.  Thus $OPT(ILP_{primal}) \leq val(P^{*}) $.</p>
<p>Then we prove $OPT(ILP_{primal}) \geq val(P^{*}) $ by arguing that $ILP_{primal}$ can be translated into a simple path from $s$ to $t$.</p>
<p>Consider the set of edges $E’:&#x3D; {e_i: x_i&#x3D; 1 \text{ for } OPT(ILP_{primal})}$, it must include some simple path from $s$ to $t$, otherwise it cannot be a feasible solution of $ILP_{primal}$.  Then, since it’s optimal, it cannot include other edges except edges from the path(If it includes other edges, by removing these edges we can get a cheaper feasible solution for $ILP_{primal} $. </p>
<p>In all we have $OPT(ILP_{Primal}) &#x3D; val(P^{*})$</p>
<p>Thus it’s easy to get $val(y^{*}) &#x3D; val(x^{*}) \leq OPT(ILP_{Primal}) &#x3D; val(P^{*})$</p>
<p><strong>Question 5</strong><br>Initially $y$ is feasible.</p>
<p>In each iteration, we will never violate any constraint, so $y$ is always feasible.</p>
<p><strong>Question 6</strong></p>
<p>$val(y) \leq val(y^{*}) \leq val(P^{*})$</p>
<p><strong>Question 7</strong></p>
<p>$e$ is added into $F$ if and only if  $w_e &#x3D; \sum_{S \in \mathcal{S}: e \in \delta(S)}{y_S}$.</p>
<p><strong>Question 8</strong><br>$\sum_{e \in P}{w_e} &#x3D; \sum_{e \in P}\sum_{S \in \mathcal{S}: e \in \delta(S)}{y_S} $</p>
<p><strong>Question 9</strong></p>
<p>$$<br>\begin{aligned}<br>\sum_{e \in P}\sum_{S \in \mathcal{S}: e \in \delta(S)}{y_S} &amp;&#x3D;<br>\sum_{S \in \mathcal{S}}{y_S}\sum_{e \in P \cap \delta(S)}{1} \<br>&amp;&#x3D; \sum_{S \in \mathcal{S}}{y_S}|P \cap \delta(S)| \<br>&amp;&#x3D; \sum_{S \in \mathcal{S} \ y_S\gt 0}{y_S}|P \cap \delta(S)|<br>\end{aligned}<br>$$</p>
<p><strong>Question 10</strong></p>
<p>If $y_S \gt 0$, then $|P \cap \delta(S)| \geq 1$, otherwise $P\cap \delta(S) &#x3D; \emptyset$ and $S &#x3D; V$, but $y_V &#x3D; 0$.</p>
<p>If $y_S \gt 0$ and $|P \cap \delta(S)| \geq 2$,  then $P$ crosses $S$ and $V \backslash S$ multiple times.</p>
<p>Since $y_S \gt 0$, $S$ must be some $C_i$ during the algorithm, which means $S$ is connected by the edges in $F_i$.</p>
<p>$P:&#x3D; (v_1, v_2, \cdots, v_i, \cdots, v_j, \cdots)$</p>
<p>Let $i$ be the least index such that $v_i \in S, v_{i+1} \notin S$, and $j$ be the least index such that $j \gt i, v_{j-1} \notin S, v_{j} \in S$.  </p>
<p>Since $S$ is connected by the edges in $F_i$, there must be some path $P_1$ from $v_j$ to $v_i$, passing all vertices in $S$.</p>
<p>Let path $P_2$ be the subpath of $P$, going from $v_i$ to $v_j$. </p>
<p>If we concatenate $P_2$ and $P_1$, we get a cycle consisting of edges in $F$, but $F$ is a tree, leading to contradiction.</p>
<p>In conclusion, If $y_S \gt 0$, then  $|P \cap \delta(S)| &#x3D; 1$.</p>
<p><strong>Question 11</strong><br>$$<br>\begin{aligned}<br>val(P) &#x3D; \sum_{e \in P}{w_e} &amp;&#x3D;<br>\sum_{e \in P}\sum_{S \in \mathcal{S}: e \in \delta(S)}{y_S}  \<br>&amp;&#x3D;\sum_{S \in \mathcal{S}}{y_S}\sum_{e \in P \cap \delta(S)}{1} \<br>&amp;&#x3D; \sum_{S \in \mathcal{S}}{y_S}|P \cap \delta(S)| \<br>&amp;&#x3D; \sum_{S \in \mathcal{S} \ y_S\gt 0}{y_S}|P \cap \delta(S)| \<br>&amp;&#x3D; \sum_{S \in \mathcal{S} \ y_S\gt 0}{y_S} \<br>&amp;&#x3D; val(y) \<br>&amp;\leq val(y^*)<br>\end{aligned}<br>$$</p>
<p>On the other hand, $val(y^*) &#x3D; val(x^*) \leq val(P)$</p>
<p>Therefore,  $val(P) &#x3D; val(x^*) \leq OPT(ILP_{primal})$.</p>
<p>$P$ is a feasible solution of $ILP_{primal}$, $val(P) \geq OPT(ILP_{primal})$.</p>
<p>In all, $val(P) &#x3D; OPT(ILP_{primal})$</p>
<p>Amazingly, $P$ is just the shortest path from $s$ to $t$ !!</p>
<p><strong>Question 12</strong></p>
<p>The key to the proof is  that if $y_S \gt 0$, then  $|P \cap \delta(S)| &#x3D; 1$.</p>
<p>In this part, we get rid off edges that are not in $P$.</p>
<p><strong>Question 13</strong></p>
<p>Edge $(s, i)$ is added into $F$ if and only if $w(s, i) &#x3D; \min\limits_{v \text{ is incident to }  s}{w(s,v)}$.</p>
<p>Also $i$ is the second vertex added to $D$ if and only if $w(s, i) &#x3D; \min\limits_{v \text{ is incident to }  s}{w(s,v)}$.</p>
<p><strong>Question 14</strong></p>
<p>Vertex $j$ that $j \notin C_0, l(j) &#x3D; \min\limits_{k \notin C_0}{l(k)}$</p>
<p><strong>Question 15</strong></p>
<p>$(j, k)$ such that $k \notin S$</p>
<p><strong>Question 16</strong></p>
<p>$l(k):&#x3D; \min(l(k), l(j)+w(j,k))$</p>
<p><strong>Question 17</strong></p>
<p>Initially, $D &#x3D; C &#x3D; {s}$ and $d(s) &#x3D; 0, l(s) &#x3D; 0$.</p>
<p>In each iteration, $d(x)$ and $l(x)$ are modified in the same way, and a new vertex $u$ is chosen to be added if and only if $x$ is not currently in the set and $d(x)$ or $l(x)$ is minimum. </p>
<p>By induction we can conclude that the primal-dual algorithm is exactly the same with Dijkstra Algorithm.</p>
<p><strong>Question 18</strong></p>
<p>$O(|E|+|V|\log(\frac{|E|}{|V|})\log(|V|))$ using Fibonacci heaps.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2019/08/28/Approximation-Algorithm-6-Linear-Programming-Duality/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/28/Approximation-Algorithm-6-Linear-Programming-Duality/" class="post-title-link" itemprop="url">Approximation Algorithm(6)-Linear Programming Duality</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-28 11:01:20" itemprop="dateCreated datePublished" datetime="2019-08-28T11:01:20+00:00">2019-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Week 6: Linear Programming Duality</strong></p>
<p>本周学习的内容是利用线性规划的对偶来设计近似算法。</p>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>考虑下面一个线性规划问题：<br>$$<br>\begin{aligned}<br>&amp;\min 7x_1 + x_2 + 5x_3 \<br>&amp;x_1-x_2+3x_3 &amp;\geq 10 \ \ &amp;(1)\<br>&amp;5x_1 + 2x_2 - x_3 &amp;\geq 6  &amp;(2) \<br>&amp;x_1, x_2, x_3 &amp;\geq 0 &amp;(3,4,5)<br>\end{aligned}<br>$$<br>$2*(1) + (2)$ 可以得到$7x_1 + 5x_3 \geq 26$。</p>
<p>因此目标函数$7x_1+x_2+5x_3\geq 7x_1+5x_3 \geq 26$</p>
<p>从上面的例子受到启发，我们可以通过构造线性规划的约数不等式的凸组合来得到目标函数的下界。</p>
<p>那么要如何构造凸组合使得这个下界尽可能紧呢？</p>
<p>考虑凸组合$y_1*(1) + y_2*(2)$:</p>
<p>$$<br>(y_1+5y_2)x_1 + (-y_1+2y_2)x_2 + (3y_1-y_2)x_3 \geq 10y_1+6y_2<br>$$</p>
<p>需要满足<br>$$<br>\begin{aligned}<br>&amp;\max 10y_1 + 6y_2 \<br>&amp; y_1+5y_2 &amp;\leq 7 \ \ \ &amp;(1’)\<br>&amp; -y1+2y_2 &amp;\leq 1 &amp;(2’)\<br>&amp; 3y_1 -y_2 &amp; \leq 5 &amp;(3’)\<br>&amp; y_1, y_2 &amp;\geq 0 &amp;(4’,5’)<br>\end{aligned}<br>$$<br>于是又转换成了一个线性规划问题。</p>
<p>写成矩阵的形式：</p>
<table>
<thead>
<tr>
<th align="center">Primal</th>
<th align="center">Dual</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$$\begin{aligned} \min c^Tx  \ Ax \geq b \x \geq 0 \end{aligned}$$</td>
<td align="center">$$\begin{aligned} \max b^Ty \ A^Ty \leq c \ y \geq 0 \end{aligned} $$</td>
</tr>
<tr>
<td align="center">上面两个线性规划问题互为对偶，以前学过的对偶问题还有最大流最小割，平面图的对偶等。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="Properties-of-LP-Duality"><a href="#Properties-of-LP-Duality" class="headerlink" title="Properties of LP Duality"></a>Properties of LP Duality</h4><p>在上一节的例子中，我们通过构造线性规划的约数不等式的凸组合来得到目标函数的下界，为了使得得到的下界尽可能紧，又转化为一个与原问题对偶的线性规划问题。问题是，通过这样得出的最紧的下界，是不是就是原问题的解呢？</p>
<h5 id="Weak-Duality-Theorem"><a href="#Weak-Duality-Theorem" class="headerlink" title="Weak Duality Theorem"></a>Weak Duality Theorem</h5><p>从例子也容易知道</p>
<p>$$<br>\max b^Ty \leq \min c^Tx<br>$$<br>因为 $ \max b^Ty $ 就是我们要求的最紧的$ \min c^Tx$的下界。</p>
<p>从矩阵的角度也很容易证明：</p>
<p>$$<br>b^Ty \leq (Ax)^Ty &#x3D; x^TA^Ty \leq x^Tc &#x3D; c^Tx<br>$$</p>
<h5 id="Strong-Duality-Theorem"><a href="#Strong-Duality-Theorem" class="headerlink" title="Strong Duality Theorem"></a>Strong Duality Theorem</h5><p>$$<br>\max b^Ty &#x3D; \min c^Tx<br>$$</p>
<p>证明可以从单纯形算法导出，利用单纯形算法最终检验数非负的性质强行构造出一个对偶解和原始解的值一样。可以看单纯形算法的各种资料。</p>
<h5 id="Complementary-Slackness-Conditions"><a href="#Complementary-Slackness-Conditions" class="headerlink" title="Complementary Slackness Conditions"></a>Complementary Slackness Conditions</h5><p>根据<strong>Strong Duality Theorem</strong>, <strong>Weak Duality Theorem</strong>中$b^Ty \leq (Ax)^Ty &#x3D; x^TA^Ty \leq x^Tc &#x3D; c^Tx$所有不等式等号都应该成立。</p>
<p>要使得$b^Ty \leq (Ax)^Ty$的等号成立, 必须有$y_i &#x3D; 0$或者$b^T_i &#x3D; (Ax)^T_i$即$b_i &#x3D; \sum_ja_{ij}x_j$</p>
<p>要使得$x^TA^Ty \leq x^Tc$的等号成立, 必须有$x_i &#x3D; 0$或者$c_i &#x3D; (A^Ty)<em>i$即$c_i &#x3D; \sum_ja</em>{ji}y_i$</p>
<h4 id="Vertex-Cover-by-LP-Duality"><a href="#Vertex-Cover-by-LP-Duality" class="headerlink" title="Vertex Cover by LP Duality"></a>Vertex Cover by LP Duality</h4><p>下面以顶点覆盖问题为例介绍如何利用LP Duality来设计近似算法。</p>
<table>
<thead>
<tr>
<th align="center">Primal</th>
<th align="center">Dual</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$$\begin{aligned} &amp;\min w_ux_u\ x_u+x_v &amp;\geq 1  \ \forall  (u, v)\in E \ \ x_u &amp;\geq 0 \ \forall u \in V \end{aligned}$$</td>
<td align="center">$$\begin{aligned}&amp;\max y_e \  \sum_{e: u \in e}y_e &amp;\leq w_u\ \forall u \in V \ y_e &amp;\geq 0  \ \forall e \in E\end{aligned}$$</td>
</tr>
</tbody></table>
<p>Dual的组合意义：</p>
<p>相当于要给每条边加”能量”，每个点的能量是与它关联的边的能量之和，每个点限制$w_u$,表示这个点的能量不能超过$ w_u $. </p>
<h5 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h5><p>令 $x:&#x3D; (0, 0 \cdots, 0)^T, y :&#x3D; (0, 0, \cdots, 0)^T$</p>
<p>重复以下过程:</p>
<p>选取某条边 $e &#x3D; (u, v)$ 满足 $e_u + e_v \lt 1$</p>
<p>将$y_e$增大, 直到$u$或者$v$的”能量”到达瓶颈，$\sum_{e’: u\in e’}y_{e’} &#x3D; w_u$或者$\sum_{e’:v \in e’} y_{e’} &#x3D; w_v$</p>
<p>将先到达瓶颈的那个端点的x置为1，同时到达的话任选一个。</p>
<h5 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h5><p>一开始$x$不是可行解，$y$是可行解，但代价太大。</p>
<p>每次迭代都会使得$x$更加可行，因为至少会让一条未覆盖的边被覆盖(让Primal一个未被满足的限制被满足)。最终$x$是可行解。而且每次迭代不会破坏Dual的任意一个限制，只会让$y$的代价减少，因此最终$y$也是可行解。</p>
<h5 id="Approximation-Ratio"><a href="#Approximation-Ratio" class="headerlink" title="Approximation Ratio"></a>Approximation Ratio</h5><p>先发现一些小性质：</p>
<p>算法最终返回的$x, y$满足:</p>
<p>$x_u &#x3D; 0$或$x_u \neq 0, \sum_{e: u \in e}{y_e} &#x3D; w_u$.</p>
<p>$y_e &#x3D; 0$或$y_e \neq 0, x_u + x_v &#x3D; 1,2$($e &#x3D; (u, v)$).</p>
<p>对比<strong>Complementary Slackness Conditions</strong>，只不过是$x_u+x_v &#x3D; 1$的条件变成了$x_u + x_v &#x3D; 1, 2$, 放宽了2倍，可以根据这个2倍入手来证明近似度。</p>
<p><strong>Proof</strong>:<br>$$<br>\begin{aligned}<br>&amp;\sum_u{w_ux_u} &#x3D; \sum_{u:x_u \neq 0}{x_u}\sum_{e:u \in e}y_e \ \<br>&amp;&#x3D; \sum_{u:x_u \neq 0}{x_u}\sum_{e:u \in e}y_e \<br>&amp;&#x3D; \sum_{u}{x_u}\sum_{e:u \in e}y_e \<br>&amp;&#x3D; \sum_{e:e&#x3D;(u,v)}y_e(x_u+x_v) \<br>&amp;\leq 2\sum_{e}y_e \<br>&amp;\leq 2 OPT_{Dual} \<br>&amp;&#x3D; 2 OPT_{Primal} \<br>&amp;\leq 2 OPT_{Primal(int)}<br>\end{aligned}<br>$$<br>因此近似度是2.</p>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><h5 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h5><img src="/2019/08/28/Approximation-Algorithm-6-Linear-Programming-Duality/1.png" class="">
<img src="/2019/08/28/Approximation-Algorithm-6-Linear-Programming-Duality/2.png" class="">
<img src="/2019/08/28/Approximation-Algorithm-6-Linear-Programming-Duality/3.png" class="">

<h5 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h5><p><strong>Question 1</strong></p>
<p>$\max \sum\limits_{j&#x3D;1}^{n}{y_i}$</p>
<p>$\forall i \in {1,\cdots,m}, \sum_{j:e_j \in S_i}{y_j} \leq w_i$</p>
<p>$\forall i \in {1,\cdots,n}, y_i \geq 0$</p>
<p><strong>Question 2</strong></p>
<p>1</p>
<p><strong>Question 3</strong></p>
<p>The algorithm terminates in at most $n$ iterations. When it terminates, every element is covered, so it’s a feasible solution.</p>
<p><strong>Question 4</strong></p>
<p>$OPT \geq val(x^{*}) &#x3D; val(y^*)$</p>
<p><strong>Question 5</strong></p>
<p>Initially, $y &#x3D; 0$ and $y$ is feasible.</p>
<p>In each iteration, the algorithm only increases $y_i$ until some constraint is reached, which means we will never violate any constraint, so  the final solution $y$ is also feasible.</p>
<p><strong>Question 6</strong></p>
<p>$val(y) \leq val(y^*) \leq OPT$</p>
<p><strong>Question 7</strong></p>
<p>$\sum_{i:e_i\in S_j}{y_i} &#x3D; w_j$</p>
<p><strong>Question 8</strong></p>
<p>$\sum_{j\in I}{w_j} &#x3D; \sum_{j \in I}{\sum_{i:e_i\in S_j}{y_i}}$</p>
<p><strong>Question 9</strong></p>
<p>$\sum_{j\in I}{w_j} &#x3D; \sum_{j \in I}{\sum_{i:e_i\in S_j}{y_i}} &#x3D; \sum_iy_i|{j : e_i \in S_j}| \leq \sum_ify_i &#x3D; f\cdot val(y)$</p>
<p><strong>Question 10</strong></p>
<p>$\sum_{j\in I}{w_j} \leq f \cdot val(y) \leq f \cdot OPT$</p>
<p>Thus the approximation ratio of the algorithm is $f$.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhenwei Liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhenwei Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
