<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuzw1998.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言拟阵这个概念在各个场合听了很多遍了，一直没有系统地整理过。本篇基于组合优化经典教材Combinatorial Optimization-Algorithms and Complexity第12章, 主要介绍拟阵的一些基本性质和两拟阵交算法。 独立集系统和拟阵定义独立集系统$S&#x3D;(E, \mathcal{I})$, $E$是基本元素的集合, $\mathcal{I} \subseteq">
<meta property="og:type" content="article">
<meta property="og:title" content="Combinatorial Optimization-Matroid">
<meta property="og:url" content="https://liuzw1998.github.io/2020/02/15/combinatorial-optimization-matroid/index.html">
<meta property="og:site_name" content="Zhenwei&#39;s Blog">
<meta property="og:description" content="前言拟阵这个概念在各个场合听了很多遍了，一直没有系统地整理过。本篇基于组合优化经典教材Combinatorial Optimization-Algorithms and Complexity第12章, 主要介绍拟阵的一些基本性质和两拟阵交算法。 独立集系统和拟阵定义独立集系统$S&#x3D;(E, \mathcal{I})$, $E$是基本元素的集合, $\mathcal{I} \subseteq">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liuzw1998.github.io/2020/02/15/combinatorial-optimization-matroid/1.png">
<meta property="article:published_time" content="2020-02-15T17:41:11.000Z">
<meta property="article:modified_time" content="2025-11-05T02:41:00.476Z">
<meta property="article:author" content="Zhenwei Liu">
<meta property="article:tag" content="Combinatorial Optimization">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liuzw1998.github.io/2020/02/15/combinatorial-optimization-matroid/1.png">

<link rel="canonical" href="https://liuzw1998.github.io/2020/02/15/combinatorial-optimization-matroid/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

<script type="text/x-mathjax-config">
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
      tags: 'ams'
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  };
</script>

  <title>Combinatorial Optimization-Matroid | Zhenwei's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zhenwei's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuzw1998.github.io/2020/02/15/combinatorial-optimization-matroid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhenwei Liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhenwei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Combinatorial Optimization-Matroid
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-15 17:41:11" itemprop="dateCreated datePublished" datetime="2020-02-15T17:41:11+00:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-05 02:41:00" itemprop="dateModified" datetime="2025-11-05T02:41:00+00:00">2025-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Combinatorial-Optimization/" itemprop="url" rel="index"><span itemprop="name">Combinatorial Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>拟阵这个概念在各个场合听了很多遍了，一直没有系统地整理过。本篇基于组合优化经典教材<a target="_blank" rel="noopener" href="https://gitee.com/zhenweiliu/papers/raw/master/papers%20in%20blog/combinatorial_book.pdf">Combinatorial Optimization-Algorithms and Complexity</a>第12章, 主要介绍拟阵的一些基本性质和两拟阵交算法。</p>
<h3 id="独立集系统和拟阵"><a href="#独立集系统和拟阵" class="headerlink" title="独立集系统和拟阵"></a>独立集系统和拟阵</h3><p>定义独立集系统$S&#x3D;(E, \mathcal{I})$, $E$是基本元素的集合, $\mathcal{I} \subseteq 2^{E}$, $\mathcal{I}$中的元素称为独立集。<br>$\mathcal{I}$需要满足遗传性: 如果$A \in \mathcal{I}, B \subseteq A$, 那么$B \in \mathcal{I}$.</p>
<p>举例:<br>定义在无向图$G(V, E)$上的独立集系统, $\mathcal{I}$是不构成环的边集合, 显然满足遗传性。<br>求无向图的最大生成树, 实际上是先给$E$中每个元素赋予一个权值(边权), 然后求一个权值最大的独立集。<br>回忆一下kruskal算法, 每次选一条边权最大的边, 如果把它加入答案不形成环，就把它加入答案。<br>推广一下，给定任意独立系统，任意给每个元素一个非负的权值，要求权值最大的独立集，容易得到下面的贪心算法:</p>
<ol>
<li>将元素按权值从大到小排序.</li>
<li>按顺序依次考虑每个元素, 如果把这个元素加入答案后仍然是一个独立集，就加入答案。</li>
</ol>
<p>不幸的是, 这个算法只有在特定条件下才会给出最优解。<br>比如考虑求二分图图的最大权值匹配, 定义独立集为可以形成匹配的边集。考虑一个4个点3条边的图$V&#x3D;{u_1, u_2, u_3, u_4}, w(u_1,u_2)&#x3D;w(u_3, u_4)&#x3D;5, w(u_1, u_4)&#x3D;8, w(u_2, u_3) &#x3D; 1$, 贪心算法会选择边$(u_1, u_4), (u_2, u_3)$, 权值是9, 最优解是$(u_1, u_2), (u_3,u_4)$, 权值是10.<br>我们把贪心算法能够使用的独立集系统称为<strong>拟阵(matroid)</strong>, 比如上面定义在无向图边集上的独立集系统(一个边集是独立集当且仅当不包含环)，贪心算法实际上就是kruskal算法, 为了方便, 给它一个名字叫<strong>图拟阵(graphic matroid)</strong>。<br>特别地, 很多问题只要求取一个最大的独立集, 即元素权重都是单位1的特殊情况, 如果这个独立集系统是拟阵, 我们称这种拟阵叫做<strong>unweighted matroid</strong>.</p>
<h3 id="拟阵的性质"><a href="#拟阵的性质" class="headerlink" title="拟阵的性质"></a>拟阵的性质</h3><p>那么如何判定一个独立集系统$M$是不是拟阵呢？下面三条定义是等价的:</p>
<ol>
<li>$M$是拟阵, 任意给元素分配非负的权值, 贪心算法能得到最优解。</li>
<li>假设有2个独立集$I_1, I_2, |I_2| &#x3D; |I_1|+1$, 那么$\exists e \in I_1\backslash I_2, I_1 \cup e \in \mathcal{I}$. 通俗地讲，就是如果2个独立集大小相差1, 那么一定可以从大的独立集那里拿一个给小的, 使新的集合还是独立集。</li>
<li>若$A \subseteq E$, $I_1, I_2 \subseteq A$是$A$上的极大独立集, 那么$|I_1|&#x3D;|I_2|$. 也就是$E$的任意子集上的极大独立集大小相同。</li>
</ol>
<p>证明:<br>$1 \rightarrow 2:$<br>设$|I_1|&#x3D;k, |I_2| &#x3D; k+1$, 只要令<br>$$<br>w(e) &#x3D; \begin{cases}<br>    k+2 &amp; e \in I_1 \<br>    k+1 &amp; e \in I_1 \backslash I_2 \<br>    0  &amp; e \notin I_1 \cup I_2<br>\end{cases}<br>$$<br>假设$\forall e \in I_1\backslash I_2, I_1 \cup e \notin \mathcal{I}$, 按照贪心算法会选择$I_1$, 权值是$k(k+2)$, 实际上$I_2$的权值是$(k+1)(k+1)$更大，贪心算法就挂了。</p>
<p>$2 \rightarrow 3:$<br>显然, 如果$|I_1| \lt |I_2|$, 考虑$I_3 \subseteq I_2, |I_3|&#x3D;|I_1|+1$, 根据(2)可以从$I_3$那里拿一个元素给$I_1$构成一个更大的独立集, 与$I_1$是极大的矛盾。</p>
<p>$3 \rightarrow 1:$<br>假设$w(e_1) \geq w(e_2) \geq w(e_3) \geq \cdots$, 贪心算法求出的权值最大独立集是$I&#x3D;{e_{i_1}, e_{i_2}, \cdots, e_{i_m} }$, 最优解是$J&#x3D;{e_{j_1}, e_{j_2}, \cdots, e_{j_m} }$.<br>设$k$是最小的正整数满足$i_k \gt j_k$. (让$I$和$J$的元素一一对应, 前面$k-1$个都是$I$中编号小, 第$k$个是$J$中编号小, 因为$J$的权值比$I$大, $k$一定存在). 利用(3), 令$A:&#x3D;{e_1, e_2, \cdots, e_{j_k}}$, 根据贪心算法的过程 $I \cap A$是 $A$上的极大独立集, 大小为$k-1$, 而$J \cap A$也是$A$上的独立集, 甚至还不是极大的，大小却是$k$. 违反了(3). </p>
<p>另外(2)还可以推出只要两个独立集大小不一样, 就可以从大集合里拿一个给小的, 新集合还是独立集。</p>
<p>接下来引入几个概念:</p>
<ol>
<li>秩(Rank). 根据上面第3条, $E$的任意子集$A$上的极大独立集大小相等。这个大小就是$A$的秩, 记为$r(A)$.</li>
<li>基(Basis). $A$的基上的任意极大独立集称为$A$的基.</li>
<li>回路(Circuit). 极小的非独立集(相关集), 即它本身不是独立集，但删掉任意一个元素后都是独立集。</li>
</ol>
<p>为了方便理解, 我们以图拟阵为例子.<br>图拟阵中任意边集$A \subseteq E$, $r(A)$是其生成子图的生成森林边数(也就是生成子图的顶点数-联通块个数), 基就是任意生成森林, 回路就是一个简单环。</p>
<p>再看一个独立集系统, 它的元素集合是一些维数相同的向量, 独立集的定义就是线性无关的向量集合。根据线性代数的知识, 任意向量集合的极大线性无关组大小相同，即满足上面的判断独立集是否是拟阵的第3条，所以该独立集系统是一个拟阵，之后我们称它为<strong>线性拟阵</strong>。<br>线性拟阵的秩, 基都和线性代数中吻合, 回路就是极小的线性相关组。<br>参加过算法竞赛的同学可以去拿BZOJ2460练练手, 就是求一个定义域在$F_2^n$下的线性拟阵权值最大的独立集, 用贪心算法解决即可。</p>
<p>下面是关于回路的一个有用的定理:<br><strong>定理1</strong>:<br>如果往独立集$I$中加入一个元素$e$后, $I+e$不独立了, 那么$I+e$中包含唯一的一个回路。并且这个回路就是${c \mid I+e-c \in \mathcal{I}}$</p>
<p>可以拿图拟阵来理解这个定理: 考虑不成环的一些边(独立), 往里面加了一条, 如果成环(不独立), 那么会有唯一的一个简单环(回路), 这个回路就是新的边集($I+e$)里面那些去掉后会使得图没有环的边。</p>
<p>我们首先证明$C&#x3D;{c \mid I+e-c \in \mathcal{I}}$确实是$I+e$中的回路。</p>
<ul>
<li>显然$C \subseteq I+e$, 先证明$C$不是独立集。 假设$C$是独立集, 那么一定可以往$C$里面加元素将它扩充成$I+e$的一个基$C’$. 因为$r(I+e) &#x3D; r(I) &#x3D; |I|$, 因此$|C’|&#x3D;|I|$, 所以$C’ &#x3D; I+e-c, c \notin C’$, 而根据$C$的定义, $c \in C$, 导致矛盾。   </li>
<li>再证明$C$去掉任意一个元素后都是独立集. $\forall c \in C, I+e-c \in \mathcal{I}$,而$ C-e \subseteq I+e-c$, 根据遗传性$C-e \in \mathcal{I}$.</li>
</ul>
<p>唯一性证明:<br>假设还有另一个回路$D$. 考虑$c \in C \backslash D$, 容易发现$ D \subseteq I+e-c$, 根据$C$的定义, $I+e-c \in \mathcal{I}$, 从而根据遗传性推出$D$是独立集,导致矛盾。</p>
<p>下面的内容和书上不完全一致, 因为我自己看书的时候在这些地方卡了好几天, 所以我尝试用自己的方法来解释, 因此可能会有一些错误, 希望发现的兄弟指出来。</p>
<p>为了之后方便解释拟阵交的算法，还需要引入一个span的概念。<br>考虑$A \subseteq E, S(A):&#x3D;{B \mid A \subseteq B, r(A)&#x3D;r(B)}$.<br>先来验证$S(A)$关于集合的并操作封闭, 即$\forall B_1,B_2 \in S(A), B_1 \cup B_2 \in S(A)$.<br>证明:<br>设$\mathcal{B}$是$A$的基, 那么显然它也是$ B_1,  B_2$的基。 我们证明它还是$ B_1 \cup B_2$的基: 如果它不是，那么它是非极大的独立集, 那么可以往里面加一个元素使它还是独立集, 但是它已经是$ B_1,  B_2$的基了，所以又不可能往它里面加$B_1$或者$B_2$的元素, 导致矛盾。</p>
<p>定义$span(A):&#x3D;\bigcup\limits_{B_i \in S(A)} B_i$, 显然$span(A) \in S(A)$, 等价地, $span(A)$就是极大的(也是最大的)$A$的超集, 满足秩和$A$的秩一样。</p>
<p><strong>引理1</strong>: $\forall B \in S(A), span(B) &#x3D; span(A)$.<br>证明:<br>$B \in S(A) \rightarrow B \subseteq span(A) \rightarrow span(A) \in S(B) \rightarrow span(A) \subseteq span(B)$<br>$A \subseteq span(A) \subseteq span(B) \rightarrow span(B) \in S(A) \rightarrow span(B) \subseteq span(A)$.<br>所以$span(A)&#x3D;span(B)$.<br>根据上面的引理, 容易验证$span(span(A)) &#x3D; span(A)$.</p>
<p>在图拟阵中, 如果$A$是某个边集, $span(A)$ 就是往$A$中加入尽可能多的边, 使得生成子图的顶点数不会增多。</p>
<p>下面的定理更加简洁的表示出了$span(A)$.<br><strong>定理2</strong>: $span(A) &#x3D; {e \mid r(A+e)&#x3D;r(A)}$<br>证明:</p>
<ul>
<li>记$K&#x3D;{e \mid r(A+e)&#x3D;r(A)}$, 那么$K$可以写作<br>$$<br>\bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (A+e)<br>$$<br>而$\forall e \in E \backslash A, r(A+e)&#x3D;r(A)$, 有$A+e \in S(A)$, 故$K \in S(A), K \subseteq span(A)$.</li>
<li>反过来, 考虑$e \in span(A) \backslash A$, 显然$r(A+e) &#x3D; r(A)$. 因此$span(A)$可以写成<br>$$<br>\bigcup\limits_{e \in span(A) \backslash A: r(A+e)&#x3D;r(A)} (A+e)<br>$$<br>容易看到$span(A) \subseteq K$.</li>
</ul>
<p>下面为拟阵交做铺垫的两个引理:</p>
<p><strong>引理2</strong>: $span(A) &#x3D; A \cup {C \mid \text{C is circuit with all but one element in } A }$<br>证明:</p>
<ul>
<li>首先证明$span(A)$可以表示成$A$和若干特殊回路的并, 特殊回路指的是只有一个元素不在$A$内的回路。根据上面的定理<br>$$<br>\begin{aligned}<br> span(A) &amp;&#x3D; \bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (A+e) \\<br> &amp;&#x3D; A \cup \bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (A+e)  \\<br> &amp;&#x3D; A \cup \bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (\text{Basis of } A +e) \\<br> &amp;&#x3D; A \cup \bigcup\limits_{e \in E \backslash A: r(A+e)&#x3D;r(A)} (\text{Circuit consists of basis of } A \text{ and } e)<br>\end{aligned}<br>$$</li>
<li>再证明任意特殊回路$\subseteq span(A)$. 给定某个特殊回路, 我们把它表示成$I+e, I \in \mathcal{I}$, 我们只要证明$r(A+e)&#x3D;r(A)$. 假设$r(A+e) \gt r(A)$, 那么存在一个$A$的基$B, B+e \in \mathcal{I}$. 考虑$I$, 如果它不是$A$的基, 那么可以先把它扩充成$A$的基, 记作$I’$. 比较$I’$和$B+e$, 后者大小比前者大1, 因此可以从后者拿一个元素给前者, 但是这个元素不可能来自$B$, 否则$I’$就不是集了。所以这个元素只能是$e$, 因此$I’+e \in \mathcal{I}$, 而它的子集$I+e$却是一个回路, 导致矛盾。</li>
</ul>
<p><strong>引理3</strong>: 若$I \in \mathcal{I}, I+e \notin \mathcal{I}$, $C$是$I+e$中唯一的circuit, 则$\forall c \in C, span(I) &#x3D; span(I+e-c)$, 且$I+e-c \in \mathcal{I}$.<br>证明:</p>
<ul>
<li>$r(I+e)&#x3D;r(I) \rightarrow I+e \in S(I)$, 根据引理1, $span(I) &#x3D; span(I+e)$.</li>
<li>根据定理1, $I+e-c \in I$, $r(I+e-c) &#x3D;r(I+e) &#x3D;|I|$, 又因为$I+e-c \subseteq I+e$, 所以$I+e \in S(I+e-c)$, 从而有$span(I+e-c) &#x3D; span(I+e)$.</li>
<li>综上$span(I+e-c) &#x3D; span(I)$.</li>
</ul>
<h3 id="拟阵的交"><a href="#拟阵的交" class="headerlink" title="拟阵的交"></a>拟阵的交</h3><p>许多时候, 一个组合优化问题并不能表示成一个拟阵, 但是却可以表示成两个拟阵甚至更多拟阵的交。比如二分图匹配, 在最开始我们已经举了一个反例说明它虽然是个独立集系统，但并不是一个拟阵。然而，我们可以把它表示成两个拟阵的交:<br>我们用$G(L, R, E)$表示一个二分图, $L, R$分别是两边的顶点集合, $E$是边集, 也是拟阵的基本元素集合。<br>定义拟阵$M_1(E, \mathcal{I}_1)$: 边集$A \in \mathcal{I}_1$ 当且仅当$A$中边的左端点互不相同。<br>定义拟阵$M_2(E, \mathcal{I}_2)$: 边集$A \in \mathcal{I}_2$ 当且仅当$A$中边的右端点互不相同。<br>容易验证$A$是合法的匹配当且仅当$A \in \mathcal{I}_1 \cap \mathcal{I}_2$.</p>
<p>一般地, 独立集系统$S(E, \mathcal{I})$表示成$K$个拟阵的交, 记作$<br>S &#x3D; \bigcap_{i&#x3D;1}^K M_i(E, \mathcal{I}<em>i), \mathcal{I} &#x3D; \bigcap</em>{i&#x3D;1}^K \mathcal{I}_i $.</p>
<p>如果一个独立集能表示成$K$个拟阵的交的形式, 能给我们带来什么方便之处呢?</p>
<p><strong>定理3</strong>: 任意两个极大独立集$A, B$, 不妨设$|A| \leq |B|$, 一定满足$|B| \leq K|A|$.<br>从近似算法的角度, 如果只需要求最大独立集(unweighted matroid), 随便取一个极大独立集就可以做到$K$的近似比, 比如上面的不带权的二分图匹配问题, 随便取一个极大匹配, 它大小就至少是最优解的一半。</p>
<p>证明: </p>
<ul>
<li>设$A_i$是第$i$个拟阵中$A\cup B$包含$A$的极大独立集。用反证法容易证明$\forall e \in B\backslash A, e \notin \bigcap A_i \backslash A$, (如果属于, 那么$A+e$也是独立集), 也就是说, $e$最多出现在$K-1$个$Ai \backslash A$里。因为$A_i \backslash A$里面的元素只能在$B\backslash A$里, 进一步可以推出$\sum\limits_{i&#x3D;1}^{K} |A_i \backslash A| \leq (K-1)|B\backslash A| \leq (K-1)|B|$. </li>
<li>同样地, 定义$B_i$是第$i$个拟阵中$A\cup B$包含$B$的极大独立集, 根据拟阵的性质$|A_i| &#x3D; |B_i|$.</li>
<li>$$<br>  \begin{aligned}<br>  K|B| &amp;\leq \sum\limits_{i&#x3D;1}^K{|B_i|} \\<br>  &amp;&#x3D; \sum\limits_{i&#x3D;1}^K{|A_i|} \\<br>  &amp;&#x3D; \sum\limits_{i&#x3D;1}^K{(|A|+|A_i \backslash A|)} \\<br>  &amp;&#x3D; K|A| + \sum\limits_{i&#x3D;1}^K{|A_i \backslash A|} \\<br>  &amp;\leq K|A| + (K-1)|B|<br> \end{aligned}<br> $$<br> 从而推出$B \leq K|A|$.</li>
</ul>
<p>下面的定理挺有趣, 但似乎没什么卵用。<br><strong>定理4</strong>: 任意一个独立集系统$S(E, \mathcal{I})$都可以表示成有限个拟阵的交。<br>证明: </p>
<ul>
<li>设独立集系统包含$K$个极小非独立集$C_1, C_2 \cdots C_K$.</li>
<li>构造$K$个拟阵$M_i(E, \mathcal{I}_i)$, 其中$ \mathcal{I}_i &#x3D; { A \subseteq E \mid C_i \not \subseteq A}$, 用判定你真的第二条规则可以证明$M_i$是拟阵。</li>
<li>我们证明$S$可以表示成它们的交, 即$ \forall A \in \mathcal{I}$当且仅当$\forall i, A \in \mathcal{I}$, 这个根据$M_i$的定义很容易证明。</li>
</ul>
<p>上面这个整理看起来很厉害，但对大多数实际问题并没有很大的帮助, 因为由上面的方法构造出来的独立集往往是很多个拟阵的交。<br>ps: 上面两个定理来自张国川老师在zju开的课程&lt;&lt;应用运筹学基础&gt;&gt;。</p>
<p>下面的定理说明表示成三个或者超过三个拟阵的交对解决问题并没有很大的帮助。<br><strong>定理5</strong>: 如果把一个独立集系统表示成3个unweighted matroid的交, 求它的最大独立集是<strong>NP-Hard</strong>的。<br>证明:</p>
<ul>
<li>哈密顿路径问题可以规约到3拟阵交。哈密顿路径问题指的是给定有向图$G(V,E)$, 起点$s$和终点$t$, 求一条$s$到$t$的路, 且经过图中所有点一次。</li>
<li>定义$M_1$是定义在将图$G$的边去掉方向后的无向图$G’$上的图拟阵。</li>
<li>定义$M_2$是定义在图$G$上边集的拟阵, 独立的定义是每个点的出度不超过1, $t$的出度是0. (利用第三条规则证明是拟阵)</li>
<li>定义$M_3$是定义在图$G$上边集的拟阵, 独立的定义是每个点的入度不超过1, $s$的入度是0.</li>
<li>容易验证上面3个拟阵的交的独立集是若干条不相交路径的并, 且其中一条路径是从$s$到$t$. 原图存在哈密尔顿路径当且仅当最大独立集的规模是$|V|-1$.</li>
</ul>
<h3 id="Intersection-of-2-unweighted-matroids"><a href="#Intersection-of-2-unweighted-matroids" class="headerlink" title="Intersection of 2 unweighted matroids"></a>Intersection of 2 unweighted matroids</h3><p>2个拟阵的交是多项式可解的, 这里介绍一下算法(有点难理解, 需要多花点时间)。我花了很多时间去揣摩算法一步步推导的motivation, 个人觉得学习算法不但要理解算法的过程和正确性，更要学习作者是如何一步步想到这个算法的。因此我希望把下面的过程写成诱导性质的，而不是<br>直接给出一个算法，然后证明它的正确性和复杂度。</p>
<p>我们先回忆一下不带权二分图最大匹配的过程:<br>假设当前已经求得匹配$I$, 定义相对于$I$的增广路为长度为奇数的边的序列$L&#x3D;[e_1, e_2 \cdots e_{2n-1}]$, 其中$e_{2k-1} \notin I, e_{2k} \in I$, 容易验证$I \oplus S$也是一个匹配, 且大小相比$M$增加了1. 增广路定理表明如果当前匹配是$I$, 且不存在相对于$I$的增广路，那么它就是最大匹配。</p>
<p>我们从拟阵的角度来看这个过程:<br>假设我们每次是从左边($M$)的点出发找增广路.<br>$I \oplus S &#x3D; I + e_1 - e_2 + e_3 \cdots -e_{2n-2} + e_{2n-1}$.<br>$I+e_1$在保持左边独立性的前提下让独立集大小增加$1$ ($I+ e_1 \in \mathcal{I}_1$), 但多了一条边之后, 右边的某个点就会和2条边相关, 右边的独立性被破坏 ($I + e_1 \notin \mathcal{I}<em>2$).<br>$I+e_1-e_2$这一步去掉$e_2$, 又让右边满足独立($I+e_1-e_2 \in \mathcal{I}<em>2$), 而且是去掉一个元素, 左边肯定还是独立。<br>…<br>$I + e_1 - e_2 + e_3 \cdots -e</em>{2n-2} + e</em>{2n-1}$这一步在保持左边独立性的前提下让独立集大小增加1, 而且幸运的是, 右边也是独立的, 于是就找到了一条增广路。<br>这个过程本质上是在奇数步尝试增加一个元素, 并且保持$M_1$中的独立性，然而这可能会导致$M_2$中的独立性被破坏, 所以在偶数步又去掉一个元素, 使得重新满足$M_2$中的独立性, 直到在某个奇数步运气特别好, 没有破坏右边的独立性。拟阵交算法就是从中受到启发得出的。</p>
<p>上面的过程看起来似乎挺简单的？但是有一个问题，用上面的方法找增广路, 在第$i$步找一个元素$e_i$, 它符不符合要求是和$e_1, e_2 \cdots e_{i-1}$的选择有关的, 这样搜索空间就相当大了, 难以用多项式bound住, 所以我们需要把增广路的条件放宽一点, 后面会证明放宽条件之后找到的解也一定是最优解。</p>
<p>后面的内容主要是基于<a target="_blank" rel="noopener" href="https://gitee.com/zhenweiliu/papers/raw/master/papers%20in%20blog/lec11.pdf">MIT matroid lecture</a>, 因为我个人觉得书上讲得过于突兀, 有点摸不着头脑, 我看了3-4遍才看明白。相比之下MIT的这份课件要易于理解一些。当然, 能将两者结合起来看，可以更好地理解算法提出的motivation。</p>
<p>假设当前的独立集是$I \in \mathcal{I}_1 \cap \mathcal{I}_2$, 如何放宽条件呢？</p>
<ul>
<li>考虑奇数步(第$2k+1$步), 原本我们是要求$I+e_1-e_2 \cdots -e_{2k} + e_{2k+1} \in \mathcal{I}<em>1$, 但是这个条件太难了, 我们放宽成 $I-e</em>{2k}+e_{2k+1} \in \mathcal{I}_1$.</li>
<li>同理偶数步放宽成$I - e_{2k} + e_{2k-1} \in \mathcal{I}_2$.</li>
</ul>
<p>定义:</p>
<ul>
<li>$X_1 :&#x3D; {e \mid e \notin I, I+e \in \mathcal{I}_1 }$.</li>
<li>$X_2 :&#x3D; {e \mid e \notin I, I+e \in \mathcal{I}_2 }$.</li>
<li>辅助图$G$(有向图, 而且是二分图), 点是独立集基本元素, 两个点$e_x \in E \backslash I$, $e_y \in I$:<ul>
<li>如果$I-e_y+e_x \in \mathcal{I}_2$, 那么$e_x$向$e_y$连边。</li>
<li>如果$I-e_y+e_x \in \mathcal{I}_1$, 那么$e_y$向$e_x$连边。</li>
</ul>
</li>
</ul>
<p>容易验证放宽条件后的增广路(为了方便, 把它叫做”广义增广路”好了)就是辅助图中从$X_1$出发到$X_2$的一条简单路径。<br>看下面图中的例子, (a)是定义在有向图边集上的一个独立集系统, 将它表示成2个拟阵的交, $M_1$是图拟阵(独立条件是不考虑边的方向无环), $M_2$独立集的条件是每个点最多有一条入边, 当前已经选择的独立集$I&#x3D;{e_2, e_4, e_6}$, 即圈起来的边, 图(b)是相应的辅助图:</p>
<img src="/2020/02/15/combinatorial-optimization-matroid/1.png" class="">
<p>一条广义增广路对应$e_1$到$e_5$的一条简单路。观察发现, $L_1&#x3D;[e_1, e_2, e_3, e_4, e_5]$就是一条广义增广路, 但是$I \oplus L_1&#x3D;{e_1, e_3, e_5, e_6}$并不是原问题的独立集(${e_1, e_3, e_6}$构成环)。<br>再看$L_2&#x3D; {e_1, e_4, e_5}$, 观察发现$I \oplus L_2 &#x3D; {e_1, e_2, e_5, e_6} $是独立集。说明广义增广路不一定是增广路, 即$I \oplus L \in \mathcal{I}_1 \cap \mathcal{I}_2$不一定被满足。<br>注意$L_2$的长度要比$L_1$短, 因此我们大胆猜测, 如果我们找的是一条从$X_1$到$X_2$最短路, 那么这条广义增广路是增广路。</p>
<p>因此我们得到下面的算法:</p>
<ol>
<li>初始化$I:&#x3D;\emptyset$.</li>
<li>构造相对于$I$的辅助图$G(I)$.</li>
<li>找到相应的起点终点集合$X_1, X_2$.</li>
<li>用宽度优先搜索(BFS)找到从$X_1$到$X_2$最短路$L$, 令$I:&#x3D; I \oplus L$, 返回第2步。如果从$X_1$到$X_2$没路, 算法结束。</li>
</ol>
<p>幸运的是，这个算法就是对的。下面给出证明, 不关心证明的大哥们可以直接用上面的算法。 </p>
<p>首先来证明最短的广义增广路是增广路, 设最短的广义增广路$L&#x3D;{e_1, e_2 \cdots e_{2k+1}}(k&gt;&#x3D;1)$, $k&#x3D;0$的情况, 说明$e_1 \in X_1 \cap X_2$, 显然合法。<br>因为$L$是最短路, $e_2, e_3,  \cdots e_{2k+1} \notin X_1$, $e_1, e_2, \cdots e_{2k} \notin X_2$, 为了方便, 我们用$L_{i,j}$来表示$[e_i, e_2 \cdots e_j]$. </p>
<ul>
<li>$I \oplus L \in \mathcal{I}_1$:<ul>
<li>我们通过归纳法证明$\forall 0 \leq i \leq k, span_1(I+e_1) &#x3D; span_1(I\oplus L_{1, 2i+1})$, $span_i$表示第$i$个拟阵的span, 显然这个结论比$I+e_1-e_2 \cdots +e_{2i+1}\in \mathcal{I}_1$更强。   </li>
<li>$i &#x3D; 0$显然成立。</li>
<li>考虑$i \geq 1$, 因为$I \in \mathcal{I}<em>1, I+e</em>{2i+1} \notin \mathcal{I_1}(否则e_{2i+1}\in X_1)$, 那么$I+e_{2i+1}$包含唯一circult $C$, 且$e_{2i} \in C$。</li>
<li>假设$span_1(I+e_1) &#x3D; span_1(I\oplus L_{1,2i-1})$, 那么$I\oplus L_{1,2i-1} \in \mathcal{I}<em>1$。如果${e_2, e_4, \cdots e</em>{2i-2} }$中的某一个$e_j \in C$, 那么$I-e_j+e_{2i+1} \in \mathcal{I}<em>1$, 根据辅助图的定义$e_j$到$e</em>{2i+1}$有边, 那么$[e_1, e_2 \cdots e_{2i+1}]$就不是最短路了, 因为$[e_1, e_2, \cdots e_j, e_{2i+1}]$更短。</li>
<li>$I \oplus L_{1,2i-1} + e_{2i+1}$可以看做$I+e_{2i+1}$删去$e_2, e_4 \cdots e_{2i-2}$再加上$e_1, e_3, \cdots e_{2i-1}$, 上一条说明没有删掉$C$中的边, 因此$C \subseteq I \oplus L_{1,2i-1} + e_{2i+1} $。</li>
<li>$I \oplus L_{1,2i-1} \in \mathcal{I}<em>1$, 但是$I \oplus L</em>{1,2i-1} + e_{2i+1} $, 因此$I \oplus L_{1,2i-1} + e_{2i+1} $包含唯一circult, 并且就是$C$. </li>
<li>$e_{2i} \in C$, 所以根据引理3,<br>   $span_1(I \oplus L_{1,2i-1} + e_{2i+1} -e_{2i}) &#x3D; span_1(I \oplus L_{1,2i-1}) &#x3D; span_1(I+e_1)$.</li>
</ul>
</li>
<li>$I \oplus L \in \mathcal{I}_2$:<ul>
<li>同样使用归纳法证明, 只不过方向需要反一下, $\forall 0 \leq i \leq k, span_2(I) &#x3D; span_2(I\oplus L_{2i+1, 2k+1})$.</li>
<li>所有的证明和上面都是对称的(从$i&#x3D;k$开始, 推到$i&#x3D;0$)。</li>
</ul>
</li>
</ul>
<p>最后还剩下一件事, 我们得证明如果不存在从$X_1$到$X_2$的广义增广路, 那么当前独立集$I$就是最大的。</p>
<p><strong>定理6(Min-Max Formula)</strong>:<br>$$<br>\max_{I \in \mathcal{I}}|I| &#x3D; \min_{U \subseteq E}{r_1(U)+r_2(E \backslash U)}<br>$$<br>首先容易证明$\forall I \in \mathcal{I}, \forall U \subseteq E, |I| \leq r_1(U)+r_2(E \backslash U)$:</p>
<ul>
<li>把$I$分成$A&#x3D;I \cap U和B&#x3D; I \backslash A$两部分。</li>
<li>$A \subseteq U, A \in \mathcal{I}_1 \rightarrow r_1(U) \geq |A|$.</li>
<li>$B \subseteq E \backslash U, B \in \mathcal{I}_2 \rightarrow r_2(E \backslash U) \geq |B|$.</li>
</ul>
<p>考虑算法的最后一次迭代, 也就是发现$X_1$到$X_2$没有路的时候, 所求出的独立集是$I$.<br>如果$X_1$或者$X_2$是空集, 那么$I$是$M_1$或者$M_2$的极大独立集, 显然$I$就是最大独立集。之后默认$X_1,X_2 \neq \emptyset$。<br>令$U$为辅助图中能到达$X_2$的元素的集合, 我们证明$|I| &#x3D; r_1(U) + r_2(E \backslash U)$, 即上面的定理的等号成立。</p>
<ul>
<li>$X_2 \subseteq U, X_1 \cap U &#x3D; \emptyset$, 否则算法会继续迭代。</li>
<li>证明$r_1(U)&#x3D;|I\cap U|$:<ul>
<li>假设$ r_1(U) \neq |I\cap U|$, 那么$r_1(U) \gt |I \cap U|$, 进而$\exists x\in U \backslash I, (I \cap U) + x \in \mathcal{I}_1$.</li>
<li>如果$I \subseteq U$,即$I \cap U &#x3D; I$, 那么$I+x \in \mathcal{I}_1$, 说明$e \in X_1$, 而$X_1 \cap U &#x3D; \emptyset$, 所以这种情况不可能发生, 也就是说$I \backslash U \neq \emptyset$.</li>
<li>因为$I \cap U + x \in \mathcal{I}_1$, 所以$I+e$要么$\in \mathcal{I}_1$, 要么包含唯一的circuit, 不管哪种情况, 都$\exists y \in I \backslash U, I+x-y \in \mathcal{I}_1$, 从而根据辅助图的定义$y$到$x$有边, 根据$U$的定义$x \in U$可以推出$y \in U$, 导致矛盾。</li>
</ul>
</li>
<li>同理可以证明$r_2(E \backslash U) &#x3D; |I \cap (E \backslash U)|$, 和前面部分是对称的。</li>
<li>综上$|I| &#x3D; r_1(U) + r_2(E \backslash U)$。</li>
</ul>
<h3 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h3><p><a target="_blank" rel="noopener" href="https://www.codechef.com/OCT19A/problems/CNNCT2">codechef monthly challenge的一个题目</a>。<br>题目大意是给出两个$n$个点$m$条边的无向图$G_1(V_1, E_1), G_2(V_2, E_2)$, 求一个最小的下标集合$J$, 使得$G_1(V_1, E_1(J))$和$G_2(V_2, E_2(J))$ 都是联通的。</p>
<p>这个题需要转化一下, 只需要求出定义在$G_1$和$G_2$上的图拟阵的交的最大独立集$|I|$,容易验证 $|J| &#x3D; 2n-2-|I| $。</p>
<p>求两个图拟阵的交的细节:<br>构造辅助图：</p>
<ul>
<li>$X_1, X_2$就是加入后仍然不构成环的那些边。只需要预处理每个点属于哪个联通块(DFS&#x2F;并查集)。</li>
<li>如果$I-e_y+e_x \in \mathcal{I}_2$, 那么$e_x$向$e_y$连边。实际上只需要考虑加入第$i$条边后, 如果在$G_2$中构成环, 那么环上的每条边 对应的点在辅助图中 向第$i$条边对应的点 连边。</li>
<li>如果$I-e_y+e_x \in \mathcal{I}_1$, 那么$e_y$向$e_x$连边。实际上只需要考虑加入第$i$条边后, 如果在$G_1$中构成环, 那么环上的每条边 对应的点在辅助图中 向第$i$条边对应的点 连边。</li>
<li>如何遍历一个环: 我的做法是将森林预处理成有根树的集合, 边$(u,v)$加入后如果形成环, 那么让$u, v$沿着父亲边向上走直到他们在最近公共祖先相遇。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.codechef.com/viewsolution/29825505">参考代码</a></p>
<p>还有几个练习题也是拟阵交：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3792">2011-2012 ACM&#x2F;ICPC, Asia, Dhaka. E. Game of Connect</a></li>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1284/problem/G">Hello 2020. G. Seollal</a></li>
<li><a target="_blank" rel="noopener" href="https://naipc18.kattis.com/problems/rainbowgraph">NAIPC 2018. G. Rainbow Graph</a></li>
<li><a target="_blank" rel="noopener" href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051707/0000000000158f1c">Google Code Jam 2019. Round 3. Datacenter Duplex</a></li>
<li><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=6636">2019 Multi-University Training Contest 6. C. Milk Candy</a></li>
<li><a target="_blank" rel="noopener" href="https://contest.yandex.com/contest/7636/problems/F/">Yandex Algorithm 2018. Round 1. F. Yet Another Binary Matrix</a></li>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/gym/102156/problem/D">2019 Petrozavodsk Winter Camp Yandex Cup. D. Pick Your Own Nim</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Combinatorial-Optimization/" rel="tag"># Combinatorial Optimization</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/01/Binpacking-First-Fit/" rel="prev" title="Binpacking-First Fit">
      <i class="fa fa-chevron-left"></i> Binpacking-First Fit
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/11/04/duckdb_sorting/" rel="next" title="DuckDB 的排序算法">
      DuckDB 的排序算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E9%9B%86%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%8B%9F%E9%98%B5"><span class="nav-number">2.</span> <span class="nav-text">独立集系统和拟阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%9F%E9%98%B5%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">3.</span> <span class="nav-text">拟阵的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%9F%E9%98%B5%E7%9A%84%E4%BA%A4"><span class="nav-number">4.</span> <span class="nav-text">拟阵的交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Intersection-of-2-unweighted-matroids"><span class="nav-number">5.</span> <span class="nav-text">Intersection of 2 unweighted matroids</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0"><span class="nav-number">6.</span> <span class="nav-text">编程练习</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhenwei Liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhenwei Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
